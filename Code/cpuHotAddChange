# VM Configuration Update Script - ENHANCED PARALLEL VERSION WITH DETAILED CONSOLE OUTPUT
# This script processes a CSV file to update VM CPU and memory settings in parallel

# Specify the CSV file path here
$CSVPath = "C:\path\to\your\vmlist.csv"

# Specify the report file path here
$ReportPath = "C:\Reports\VM_Configuration_Report_$(Get-Date -Format 'yyyyMMdd_HHmmss').csv"

Write-Host "Starting VM Configuration Update Script (Enhanced Parallel Mode)..." -ForegroundColor Green
Write-Host "Script started at: $(Get-Date)" -ForegroundColor Gray

# Set PowerCLI configuration to ignore certificate warnings
Write-Host "Configuring PowerCLI settings..." -ForegroundColor Yellow
try {
    Set-PowerCLIConfiguration -InvalidCertificateAction Ignore -Confirm:$false -Scope Session
    Write-Host "PowerCLI configuration set successfully" -ForegroundColor Green
} catch {
    Write-Warning "Failed to set PowerCLI configuration: $($_.Exception.Message)"
}

# vCenter connection parameters
$vCenterServers = @(
    "test.test.test",
    "test.test.test", 
    "test.test.test",
    "test.test.test",
    "test.test.test"
)

Write-Host "Starting VM Configuration Update Process" -ForegroundColor Cyan
Write-Host "CSV File: $CSVPath" -ForegroundColor Yellow
Write-Host "Report will be saved to: $ReportPath" -ForegroundColor Yellow

# Validate CSV file exists
Write-Host "Checking CSV file..." -ForegroundColor Yellow
if (!(Test-Path $CSVPath)) {
    Write-Error "CSV file not found at path: $CSVPath"
    Read-Host "Press Enter to exit"
    exit 1
}
Write-Host "CSV file found successfully" -ForegroundColor Green

# Read and validate CSV file
Write-Host "Reading CSV file..." -ForegroundColor Yellow
try {
    $VMList = Import-Csv -Path $CSVPath
    Write-Host "Successfully imported CSV with $($VMList.Count) VMs" -ForegroundColor Green
    
    if ($VMList.Count -eq 0) {
        Write-Error "CSV file is empty or contains no data rows"
        Read-Host "Press Enter to exit"
        exit 1
    }
} catch {
    Write-Error "Failed to import CSV file: $($_.Exception.Message)"
    Read-Host "Press Enter to exit"
    exit 1
}

# Validate CSV headers
Write-Host "Validating CSV headers..." -ForegroundColor Yellow
$requiredHeaders = @("VMName", "PowerState", "CPUHotAddEnabled", "MemoryHotAddEnabled", "CPUCountBefore", "CPUCountAfter")
$csvHeaders = $VMList[0].PSObject.Properties.Name
$missingHeaders = $requiredHeaders | Where-Object { $_ -notin $csvHeaders }

if ($missingHeaders) {
    Write-Error "Missing required CSV headers: $($missingHeaders -join ', ')"
    Write-Host "Required headers: $($requiredHeaders -join ', ')" -ForegroundColor Yellow
    Read-Host "Press Enter to exit"
    exit 1
}
Write-Host "CSV headers validated successfully" -ForegroundColor Green

# Connect to vCenter servers
Write-Host "Preparing to connect to vCenter servers..." -ForegroundColor Yellow
$Credential = Get-Credential -Message "Enter vCenter credentials"

if (!$Credential) {
    Write-Error "No credentials provided. Exiting."
    Read-Host "Press Enter to exit"
    exit 1
}

$connectedServers = @()

Write-Host "Attempting to connect to vCenter servers..." -ForegroundColor Yellow
foreach ($vc in $vCenterServers) {
    Write-Host "Connecting to $vc..." -ForegroundColor Gray
    try {
        Connect-VIServer -Server $vc -Credential $Credential -ErrorAction Stop
        Write-Host "Connected to $vc" -ForegroundColor Green
        $connectedServers += $vc
    } catch {
        Write-Warning "Failed to connect to $vc : $($_.Exception.Message)"
    }
}

if ($connectedServers.Count -eq 0) {
    Write-Error "Failed to connect to any vCenter servers"
    Read-Host "Press Enter to exit"
    exit 1
}

Write-Host "Successfully connected to $($connectedServers.Count) vCenter server(s)" -ForegroundColor Green

# Display confirmation
Write-Host "`n" + "=" * 80 -ForegroundColor Yellow
Write-Host "VM CONFIGURATION CHANGE CONFIRMATION" -ForegroundColor Yellow
Write-Host "=" * 80 -ForegroundColor Yellow

foreach ($vmEntry in $VMList) {
    Write-Host "VM: $($vmEntry.VMName) | CPU: $($vmEntry.CPUCountBefore) -> $($vmEntry.CPUCountAfter) | Hot Add: Enabled" -ForegroundColor Cyan
}

Write-Host "`nTotal VMs: $($VMList.Count) | Processing: PARALLEL" -ForegroundColor Yellow
Write-Host "WARNING: VMs will be shut down and reconfigured!" -ForegroundColor Red
Write-Host "`nPress ENTER to continue or CTRL+C to cancel..." -ForegroundColor White
Read-Host

# Create robust script block for parallel processing
$vmProcessingScript = {
    param($vmData, $vCenterList, $username, $password, $jobId)
    
    # Create a unique log identifier
    $logPrefix = "[$($vmData.VMName)][Job$jobId]"
    $progressLog = @()
    
    function Add-ProgressLog {
        param($Message, $LogLevel = "INFO")
        $timestamp = Get-Date -Format "HH:mm:ss.fff"
        $logEntry = "$timestamp $logPrefix [$LogLevel] $Message"
        $script:progressLog += $logEntry
        
        # Create structured output for console processing
        $output = [PSCustomObject]@{
            Type = "ProgressUpdate"
            VMName = $vmData.VMName
            JobId = $jobId
            Timestamp = $timestamp
            LogLevel = $LogLevel
            Message = $Message
            FullLogEntry = $logEntry
        }
        Write-Output $output
    }
    
    try {
        Add-ProgressLog "STARTING - Initializing job environment" "START"
        
        # Recreate credential securely
        $securePassword = ConvertTo-SecureString -String $password -AsPlainText -Force
        $jobCredential = New-Object System.Management.Automation.PSCredential($username, $securePassword)
        
        # Import PowerCLI with complete banner suppression
        $moduleLoaded = $false
        $retryCount = 0
        
        # Redirect all output streams to suppress banner
        $originalVerbosePreference = $VerbosePreference
        $originalInformationPreference = $InformationPreference
        $originalWarningPreference = $WarningPreference
        
        $VerbosePreference = "SilentlyContinue"
        $InformationPreference = "SilentlyContinue" 
        $WarningPreference = "SilentlyContinue"
        
        while (-not $moduleLoaded -and $retryCount -lt 3) {
            try {
                # Completely suppress all output during module import
                $null = Import-Module VMware.PowerCLI -Force -Global -ErrorAction Stop -WarningAction SilentlyContinue -InformationAction SilentlyContinue -Verbose:$false 6>$null 3>$null 2>$null
                
                # Set all PowerCLI configurations immediately to suppress any remaining messages
                $null = Set-PowerCLIConfiguration -InvalidCertificateAction Ignore -Confirm:$false -Scope Session -ErrorAction SilentlyContinue -WarningAction SilentlyContinue -InformationAction SilentlyContinue -Verbose:$false 6>$null 3>$null 2>$null
                $null = Set-PowerCLIConfiguration -DisplayDeprecationWarnings $false -Confirm:$false -Scope Session -ErrorAction SilentlyContinue -WarningAction SilentlyContinue -InformationAction SilentlyContinue -Verbose:$false 6>$null 3>$null 2>$null
                $null = Set-PowerCLIConfiguration -ParticipateInCEIP $false -Confirm:$false -Scope Session -ErrorAction SilentlyContinue -WarningAction SilentlyContinue -InformationAction SilentlyContinue -Verbose:$false 6>$null 3>$null 2>$null
                $null = Set-PowerCLIConfiguration -DefaultVIServerMode Single -Confirm:$false -Scope Session -ErrorAction SilentlyContinue -WarningAction SilentlyContinue -InformationAction SilentlyContinue -Verbose:$false 6>$null 3>$null 2>$null
                $null = Set-PowerCLIConfiguration -WebOperationTimeoutSeconds 300 -Confirm:$false -Scope Session -ErrorAction SilentlyContinue -WarningAction SilentlyContinue -InformationAction SilentlyContinue -Verbose:$false 6>$null 3>$null 2>$null
                
                $moduleLoaded = $true
                Add-ProgressLog "INITIALIZED - PowerCLI loaded successfully (banner completely suppressed)" "SUCCESS"
            } catch {
                if (Get-Module -ListAvailable -Name VMware.VimAutomation.Core) {
                    try {
                        # Try legacy module import with complete suppression
                        $null = Import-Module VMware.VimAutomation.Core -Force -Global -ErrorAction Stop -WarningAction SilentlyContinue -InformationAction SilentlyContinue -Verbose:$false 6>$null 3>$null 2>$null
                        $null = Import-Module VMware.VimAutomation.Common -Force -Global -ErrorAction SilentlyContinue -WarningAction SilentlyContinue -InformationAction SilentlyContinue -Verbose:$false 6>$null 3>$null 2>$null
                        
                        # Set configurations with complete suppression
                        $null = Set-PowerCLIConfiguration -InvalidCertificateAction Ignore -Confirm:$false -Scope Session -ErrorAction SilentlyContinue -WarningAction SilentlyContinue -InformationAction SilentlyContinue -Verbose:$false 6>$null 3>$null 2>$null
                        $null = Set-PowerCLIConfiguration -DisplayDeprecationWarnings $false -Confirm:$false -Scope Session -ErrorAction SilentlyContinue -WarningAction SilentlyContinue -InformationAction SilentlyContinue -Verbose:$false 6>$null 3>$null 2>$null
                        $null = Set-PowerCLIConfiguration -ParticipateInCEIP $false -Confirm:$false -Scope Session -ErrorAction SilentlyContinue -WarningAction SilentlyContinue -InformationAction SilentlyContinue -Verbose:$false 6>$null 3>$null 2>$null
                        $null = Set-PowerCLIConfiguration -DefaultVIServerMode Single -Confirm:$false -Scope Session -ErrorAction SilentlyContinue -WarningAction SilentlyContinue -InformationAction SilentlyContinue -Verbose:$false 6>$null 3>$null 2>$null
                        
                        $moduleLoaded = $true
                        Add-ProgressLog "INITIALIZED - PowerCLI legacy modules loaded (banner completely suppressed)" "SUCCESS"
                    } catch {
                        $retryCount++
                        Add-ProgressLog "MODULE_RETRY - Legacy import attempt $retryCount failed: $($_.Exception.Message)" "WARN"
                        Start-Sleep -Seconds 2
                    }
                } else {
                    throw "PowerCLI modules not found"
                }
            }
        }
        
        # Restore original preference variables
        $VerbosePreference = $originalVerbosePreference
        $InformationPreference = $originalInformationPreference
        $WarningPreference = $originalWarningPreference
        
        if (-not $moduleLoaded) {
            throw "Failed to load PowerCLI after 3 attempts"
        }
        
        # Initialize result object
        $result = [PSCustomObject]@{
            Type = "FinalResult"
            VMName = $vmData.VMName
            JobId = $jobId
            Status = "Processing"
            OriginalPowerState = $vmData.PowerState
            OriginalCPUCount = $vmData.CPUCountBefore
            TargetCPUCount = $vmData.CPUCountAfter
            NewCPUCount = ""
            NewCoresPerSocket = ""
            NewCPUHotAddEnabled = ""
            NewMemoryHotAddEnabled = ""
            FinalPowerState = ""
            ErrorMessage = ""
            StartTime = Get-Date
            EndTime = $null
            ProcessingTimeMinutes = 0
            ProgressLog = $progressLog
        }
        
        # Connect to vCenter servers
        Add-ProgressLog "CONNECTING - Attempting vCenter connections" "INFO"
        $jobConnections = @()
        
        foreach ($vcServer in $vCenterList) {
            try {
                $connection = Connect-VIServer -Server $vcServer -Credential $jobCredential -ErrorAction Stop
                $jobConnections += $vcServer
                Add-ProgressLog "CONNECTED - Successfully connected to $vcServer" "SUCCESS"
                
                # Try to find VM immediately
                $testVM = Get-VM -Name $vmData.VMName -Server $vcServer -ErrorAction SilentlyContinue
                if ($testVM) {
                    Add-ProgressLog "VM_LOCATED - Found VM on $vcServer" "SUCCESS"
                    break
                }
            } catch {
                Add-ProgressLog "CONNECT_FAILED - $vcServer : $($_.Exception.Message)" "ERROR"
            }
        }
        
        if ($jobConnections.Count -eq 0) {
            throw "No vCenter connections established"
        }
        
        # Locate the VM with comprehensive error handling
        Add-ProgressLog "SEARCHING - Looking for VM across $($jobConnections.Count) connected servers" "INFO"
        $targetVM = $null
        $vmServer = $null
        
        foreach ($server in $jobConnections) {
            try {
                $targetVM = Get-VM -Name $vmData.VMName -Server $server -ErrorAction Stop
                if ($targetVM -and $targetVM.Name -eq $vmData.VMName) {
                    $vmServer = $server
                    Add-ProgressLog "VM_FOUND - Located '$($targetVM.Name)' on $server (Current Power: $($targetVM.PowerState), CPUs: $($targetVM.NumCpu))" "SUCCESS"
                    break
                } else {
                    $targetVM = $null
                }
            } catch {
                Add-ProgressLog "VM_SEARCH - Not found on $server, continuing search..." "INFO"
                $targetVM = $null
            }
        }
        
        if (-not $targetVM -or -not $vmServer) {
            throw "VM '$($vmData.VMName)' not found on any connected vCenter server"
        }
        
        # Validate VM object before proceeding
        if (-not $targetVM.Name) {
            throw "VM object is invalid - Name property is missing"
        }
        
        # PHASE 1: Shutdown if needed with null checks
        if ($targetVM -and $targetVM.PowerState -eq "PoweredOn") {
            Add-ProgressLog "SHUTDOWN_START - Initiating graceful shutdown (VMware Tools required)" "INFO"
            
            try {
                Shutdown-VMGuest -VM $targetVM -Confirm:$false -ErrorAction Stop
                Add-ProgressLog "SHUTDOWN_INITIATED - Graceful shutdown command sent" "SUCCESS"
            } catch {
                Add-ProgressLog "SHUTDOWN_FALLBACK - Graceful shutdown failed, will force power off: $($_.Exception.Message)" "WARN"
                Stop-VM -VM $targetVM -Confirm:$false -ErrorAction Stop
            }
            
            $shutdownTimeout = (Get-Date).AddMinutes(8)
            $shutdownStart = Get-Date
            
            while ($targetVM -and $targetVM.PowerState -ne "PoweredOff" -and (Get-Date) -lt $shutdownTimeout) {
                Start-Sleep -Seconds 10
                
                try {
                    $targetVM = Get-VM -Name $vmData.VMName -Server $vmServer -ErrorAction Stop
                    $elapsed = [math]::Round(((Get-Date) - $shutdownStart).TotalSeconds)
                    
                    if ($elapsed % 30 -eq 0) {
                        Add-ProgressLog "SHUTDOWN_WAIT - Shutdown in progress (${elapsed}s elapsed, State: $($targetVM.PowerState))" "INFO"
                    }
                } catch {
                    Add-ProgressLog "SHUTDOWN_ERROR - Failed to refresh VM status during shutdown" "WARN"
                    break
                }
            }
            
            # Force shutdown if still running
            if ($targetVM -and $targetVM.PowerState -ne "PoweredOff") {
                Add-ProgressLog "SHUTDOWN_FORCE - Timeout reached, forcing power off" "WARN"
                try {
                    Stop-VM -VM $targetVM -Confirm:$false -ErrorAction Stop
                    Start-Sleep -Seconds 5
                    $targetVM = Get-VM -Name $vmData.VMName -Server $vmServer -ErrorAction Stop
                } catch {
                    Add-ProgressLog "SHUTDOWN_FORCE_ERROR - Failed to force power off: $($_.Exception.Message)" "ERROR"
                }
            }
            
            if ($targetVM) {
                $shutdownDuration = [math]::Round(((Get-Date) - $shutdownStart).TotalSeconds)
                Add-ProgressLog "SHUTDOWN_COMPLETE - VM powered off (took ${shutdownDuration}s, Final State: $($targetVM.PowerState))" "SUCCESS"
            }
        } else {
            Add-ProgressLog "SHUTDOWN_SKIP - VM already powered off or invalid, proceeding to reconfiguration" "INFO"
        }
        
        # PHASE 2: Reconfigure VM with enhanced error handling and better null checks
        Add-ProgressLog "CONFIG_START - Beginning VM reconfiguration" "INFO"
        
        # Re-get VM object before reconfiguration to ensure it's valid
        try {
            $targetVM = Get-VM -Name $vmData.VMName -Server $vmServer -ErrorAction Stop
            if (-not $targetVM) {
                throw "VM object is null after retrieval"
            }
            
            Add-ProgressLog "CONFIG_VM_RETRIEVED - VM object refreshed successfully" "SUCCESS"
            
            # Additional validation before creating view
            if (-not $targetVM.Name -or [string]::IsNullOrEmpty($targetVM.Name)) {
                throw "VM object has null or empty Name property"
            }
            
            if (-not $targetVM.Id -or [string]::IsNullOrEmpty($targetVM.Id)) {
                throw "VM object has null or empty Id property"
            }
            
            Add-ProgressLog "CONFIG_VM_VALIDATED - VM object validation passed" "SUCCESS"
            
            # Try to get the view object with better error handling
            $vmView = $null
            $maxViewRetries = 3
            $viewRetryCount = 0
            
            while ($vmView -eq $null -and $viewRetryCount -lt $maxViewRetries) {
                try {
                    $vmView = Get-View -VIObject $targetVM -ErrorAction Stop
                    if ($vmView) {
                        Add-ProgressLog "CONFIG_VIEW_SUCCESS - VM View object created successfully" "SUCCESS"
                        break
                    }
                } catch {
                    $viewRetryCount++
                    Add-ProgressLog "CONFIG_VIEW_RETRY - Attempt $viewRetryCount failed: $($_.Exception.Message)" "WARN"
                    if ($viewRetryCount -lt $maxViewRetries) {
                        Start-Sleep -Seconds 2
                        # Try to refresh the VM object
                        $targetVM = Get-VM -Name $vmData.VMName -Server $vmServer -ErrorAction SilentlyContinue
                    }
                }
            }
            
            if (-not $vmView) {
                throw "Failed to create VM View object after $maxViewRetries attempts"
            }
            
        } catch {
            throw "Failed to get VM objects for reconfiguration: $($_.Exception.Message)"
        }
        
        $targetCPUs = [int]$vmData.CPUCountAfter
        
        # Log current configuration
        Add-ProgressLog "CONFIG_CURRENT - Current: $($vmView.Config.Hardware.NumCPU) CPUs, $($vmView.Config.Hardware.NumCoresPerSocket) cores/socket" "INFO"
        Add-ProgressLog "CONFIG_CURRENT - Hot Add CPU: $($vmView.Config.CpuHotAddEnabled), Hot Add Memory: $($vmView.Config.MemoryHotAddEnabled)" "INFO"
        Add-ProgressLog "CONFIG_TARGET - Target: $targetCPUs CPUs, 1 core/socket, Hot Add enabled" "INFO"
        
        $configSpec = New-Object VMware.Vim.VirtualMachineConfigSpec
        $configSpec.NumCPUs = $targetCPUs
        $configSpec.NumCoresPerSocket = 1
        $configSpec.CpuHotAddEnabled = $true
        $configSpec.MemoryHotAddEnabled = $true
        
        Add-ProgressLog "CONFIG_APPLY - Submitting configuration changes to vSphere API..." "INFO"
        $reconfigStart = Get-Date
        
        try {
            # Start the reconfiguration task
            $task = $vmView.ReconfigVM($configSpec)
            Add-ProgressLog "CONFIG_TASK - Reconfiguration task submitted (Task ID: $($task.Value))" "INFO"
            
            # Monitor the task progress
            $taskInfo = Get-View $task -ErrorAction Stop
            $timeout = (Get-Date).AddMinutes(10)  # 10 minute timeout for reconfig
            
            while ($taskInfo.Info.State -eq "running" -and (Get-Date) -lt $timeout) {
                Start-Sleep -Seconds 5
                try {
                    $taskInfo.UpdateViewData()
                    $elapsed = [math]::Round(((Get-Date) - $reconfigStart).TotalSeconds)
                    
                    # Log progress every 15 seconds
                    if ($elapsed % 15 -eq 0) {
                        Add-ProgressLog "CONFIG_PROGRESS - Reconfiguration in progress (${elapsed}s elapsed, State: $($taskInfo.Info.State))" "INFO"
                        
                        # Check if there's any progress info
                        if ($taskInfo.Info.Progress -ne $null) {
                            Add-ProgressLog "CONFIG_PROGRESS - Task progress: $($taskInfo.Info.Progress)%" "INFO"
                        }
                    }
                } catch {
                    Add-ProgressLog "CONFIG_MONITOR_ERROR - Error monitoring task: $($_.Exception.Message)" "WARN"
                    break
                }
            }
            
            # Check final task state
            try {
                $taskInfo.UpdateViewData()
                $reconfigDuration = [math]::Round(((Get-Date) - $reconfigStart).TotalSeconds)
                
                if ($taskInfo.Info.State -eq "success") {
                    Add-ProgressLog "CONFIG_COMPLETE - VM reconfiguration successful (took ${reconfigDuration}s)" "SUCCESS"
                } elseif ($taskInfo.Info.State -eq "error") {
                    $errorMsg = if ($taskInfo.Info.Error) { $taskInfo.Info.Error.LocalizedMessage } else { "Unknown error" }
                    throw "Reconfiguration failed: $errorMsg"
                } else {
                    Add-ProgressLog "CONFIG_TIMEOUT - Reconfiguration task timed out after ${reconfigDuration}s (State: $($taskInfo.Info.State))" "WARN"
                    # Don't throw error, continue and see if changes were applied
                }
            } catch {
                Add-ProgressLog "CONFIG_CHECK_ERROR - Error checking final task state: $($_.Exception.Message)" "WARN"
            }
            
        } catch {
            Add-ProgressLog "CONFIG_ERROR - Reconfiguration failed: $($_.Exception.Message)" "ERROR"
            throw $_
        }
        
        # PHASE 3: Power on based on original state - FIXED LOGIC
        Add-ProgressLog "POWERON_CHECK - Original power state from CSV: '$($vmData.PowerState)'" "INFO"
        
        # Check if VM should be powered on - specifically look for "PoweredOn"
        $shouldPowerOn = ($vmData.PowerState -eq "PoweredOn")
        
        if ($shouldPowerOn) {
            Add-ProgressLog "POWERON_START - VM was PoweredOn in CSV, will restore power state" "INFO"
            
            # Get fresh VM object for power operations
            try {
                $targetVM = Get-VM -Name $vmData.VMName -Server $vmServer -ErrorAction Stop
                
                if ($targetVM.PowerState -eq "PoweredOff") {
                    Add-ProgressLog "POWERON_EXECUTE - Starting VM power on sequence" "INFO"
                    Start-VM -VM $targetVM -Confirm:$false -ErrorAction Stop
                    Add-ProgressLog "POWERON_INITIATED - Power on command sent successfully" "SUCCESS"
                    
                    $powerOnTimeout = (Get-Date).AddMinutes(8)
                    $powerOnStart = Get-Date
                    
                    while ($targetVM.PowerState -ne "PoweredOn" -and (Get-Date) -lt $powerOnTimeout) {
                        Start-Sleep -Seconds 10
                        try {
                            $targetVM = Get-VM -Name $vmData.VMName -Server $vmServer -ErrorAction Stop
                            if ($targetVM) {
                                $elapsed = [math]::Round(((Get-Date) - $powerOnStart).TotalSeconds)
                                
                                if ($elapsed % 30 -eq 0 -or $elapsed -in @(10, 20)) {
                                    Add-ProgressLog "POWERON_WAIT - VM starting up (${elapsed}s elapsed, Current State: $($targetVM.PowerState))" "INFO"
                                }
                            }
                        } catch {
                            Add-ProgressLog "POWERON_REFRESH_ERROR - Failed to refresh VM status: $($_.Exception.Message)" "WARN"
                            break
                        }
                    }
                    
                    # Final power state check
                    try {
                        $targetVM = Get-VM -Name $vmData.VMName -Server $vmServer -ErrorAction Stop
                        $powerOnDuration = [math]::Round(((Get-Date) - $powerOnStart).TotalSeconds)
                        
                        if ($targetVM -and $targetVM.PowerState -eq "PoweredOn") {
                            Add-ProgressLog "POWERON_COMPLETE - VM powered on successfully (took ${powerOnDuration}s)" "SUCCESS"
                        } else {
                            Add-ProgressLog "POWERON_TIMEOUT - VM did not fully start within timeout (${powerOnDuration}s, Final State: $($targetVM.PowerState))" "WARN"
                        }
                    } catch {
                        Add-ProgressLog "POWERON_FINAL_CHECK_ERROR - Failed to check final power state: $($_.Exception.Message)" "WARN"
                    }
                } else {
                    Add-ProgressLog "POWERON_ALREADY - VM is already powered on (State: $($targetVM.PowerState))" "INFO"
                }
                
            } catch {
                Add-ProgressLog "POWERON_ERROR - Failed to power on VM: $($_.Exception.Message)" "ERROR"
            }
            
        } else {
            Add-ProgressLog "POWERON_SKIP - VM was '$($vmData.PowerState)' in CSV, leaving it powered off" "INFO"
        }
        
        # PHASE 4: Verify and finalize
        Add-ProgressLog "VERIFY_START - Checking final configuration" "INFO"
        
        # Re-get the VM object after reconfiguration
        $targetVM = $null
        $finalVmView = $null
        
        try {
            $targetVM = Get-VM -Name $vmData.VMName -Server $vmServer -ErrorAction Stop
            if ($targetVM) {
                $finalVmView = Get-View -VIObject $targetVM -ErrorAction Stop
                Add-ProgressLog "VERIFY_SUCCESS - Successfully retrieved updated VM configuration" "SUCCESS"
            } else {
                throw "VM object is null after reconfiguration"
            }
        } catch {
            Add-ProgressLog "VERIFY_ERROR - Failed to get updated VM info: $($_.Exception.Message)" "ERROR"
            # Try to get basic info without View
            try {
                $targetVM = Get-VM -Name $vmData.VMName -Server $vmServer -ErrorAction Stop
            } catch {
                Add-ProgressLog "VERIFY_CRITICAL - Cannot retrieve VM object at all" "ERROR"
            }
        }
        
        # Update result with final configuration if available
        if ($finalVmView) {
            $result.NewCPUCount = $finalVmView.Config.Hardware.NumCPU
            $result.NewCoresPerSocket = $finalVmView.Config.Hardware.NumCoresPerSocket
            $result.NewCPUHotAddEnabled = $finalVmView.Config.CpuHotAddEnabled
            $result.NewMemoryHotAddEnabled = $finalVmView.Config.MemoryHotAddEnabled
            
            Add-ProgressLog "FINAL_CONFIG - CPUs: $($result.NewCPUCount), Cores/Socket: $($result.NewCoresPerSocket)" "SUCCESS"
            Add-ProgressLog "VERIFICATION - Hot Add CPU: $($result.NewCPUHotAddEnabled), Hot Add Memory: $($result.NewMemoryHotAddEnabled)" "SUCCESS"
        } else {
            # Fallback - use target values
            $result.NewCPUCount = $targetCPUs
            $result.NewCoresPerSocket = 1
            $result.NewCPUHotAddEnabled = $true
            $result.NewMemoryHotAddEnabled = $true
            Add-ProgressLog "FINAL_CONFIG - Using target values (verification failed)" "WARN"
        }
        
        if ($targetVM) {
            $result.FinalPowerState = $targetVM.PowerState
        } else {
            $result.FinalPowerState = "
