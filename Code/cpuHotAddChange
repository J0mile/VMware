# Specify the CSV file path here
$CSVPath = "C:\path\to\your\vmlist.csv"

# Specify the report file path here
$ReportPath = "C:\Reports\VM_Configuration_Report_$(Get-Date -Format 'yyyyMMdd_HHmmss').csv"

Write-Host "Starting VM Configuration Update Script (Enhanced Parallel Mode)..." -ForegroundColor Green
Write-Host "Script started at: $(Get-Date)" -ForegroundColor Gray

# Set PowerCLI configuration to ignore certificate warnings
Write-Host "Configuring PowerCLI settings..." -ForegroundColor Yellow
try {
    Set-PowerCLIConfiguration -InvalidCertificateAction Ignore -Confirm:$false -Scope Session
    Write-Host "PowerCLI configuration set successfully" -ForegroundColor Green
} catch {
    Write-Warning "Failed to set PowerCLI configuration: $($_.Exception.Message)"
}

# vCenter connection parameters - REPLACE WITH YOUR ACTUAL SERVER NAMES
$vCenterServers = @(
    "vcenter1.domain.com",
    "vcenter2.domain.com", 
    "vcenter3.domain.com"
)

# DEBUG: Show what we're working with
Write-Host "DEBUG: Original vCenter servers:" -ForegroundColor Yellow
$vCenterServers | ForEach-Object { Write-Host "  - '$_'" -ForegroundColor Gray }

Write-Host "Starting VM Configuration Update Process" -ForegroundColor Cyan
Write-Host "CSV File: $CSVPath" -ForegroundColor Yellow
Write-Host "Report will be saved to: $ReportPath" -ForegroundColor Yellow

# Validate CSV file exists
Write-Host "Checking CSV file..." -ForegroundColor Yellow
if (!(Test-Path $CSVPath)) {
    Write-Error "CSV file not found at path: $CSVPath"
    Read-Host "Press Enter to exit"
    exit 1
}
Write-Host "CSV file found successfully" -ForegroundColor Green

# Read and validate CSV file
Write-Host "Reading CSV file..." -ForegroundColor Yellow
try {
    $VMList = Import-Csv -Path $CSVPath
    Write-Host "Successfully imported CSV with $($VMList.Count) VMs" -ForegroundColor Green
    
    if ($VMList.Count -eq 0) {
        Write-Error "CSV file is empty or contains no data rows"
        Read-Host "Press Enter to exit"
        exit 1
    }
} catch {
    Write-Error "Failed to import CSV file: $($_.Exception.Message)"
    Read-Host "Press Enter to exit"
    exit 1
}

# Validate CSV headers
Write-Host "Validating CSV headers..." -ForegroundColor Yellow
$requiredHeaders = @("VMName", "PowerState", "CPUHotAddEnabled", "MemoryHotAddEnabled", "CPUCountBefore", "CPUCountAfter")
$csvHeaders = $VMList[0].PSObject.Properties.Name
$missingHeaders = $requiredHeaders | Where-Object { $_ -notin $csvHeaders }

if ($missingHeaders) {
    Write-Error "Missing required CSV headers: $($missingHeaders -join ', ')"
    Write-Host "Required headers: $($requiredHeaders -join ', ')" -ForegroundColor Yellow
    Read-Host "Press Enter to exit"
    exit 1
}
Write-Host "CSV headers validated successfully" -ForegroundColor Green

# Connect to vCenter servers
Write-Host "Preparing to connect to vCenter servers..." -ForegroundColor Yellow
$Credential = Get-Credential -Message "Enter vCenter credentials"

if (!$Credential) {
    Write-Error "No credentials provided. Exiting."
    Read-Host "Press Enter to exit"
    exit 1
}

# FIXED: Validate and clean vCenter server list - CRITICAL FIX
Write-Host "Validating vCenter server list..." -ForegroundColor Yellow
$validVCenterServers = @()

foreach ($server in $vCenterServers) {
    if (-not [string]::IsNullOrWhiteSpace($server) -and $server.Trim() -ne "") {
        $cleanServer = $server.Trim()
        if ($cleanServer -ne "test.test.test" -and $cleanServer -ne "") {
            $validVCenterServers += $cleanServer
            Write-Host "  ✓ Added: '$cleanServer'" -ForegroundColor Green
        } else {
            Write-Host "  ✗ Skipped placeholder: '$cleanServer'" -ForegroundColor Red
        }
    } else {
        Write-Host "  ✗ Skipped empty/null server" -ForegroundColor Red
    }
}

if ($validVCenterServers.Count -eq 0) {
    Write-Error "No valid vCenter servers found in the list. Please update the vCenterServers array with your actual server names."
    Write-Host "Current servers in array:" -ForegroundColor Red
    $vCenterServers | ForEach-Object { Write-Host "  - '$_'" -ForegroundColor Red }
    Write-Host "Please replace 'test.test.test' with your actual vCenter server FQDNs or IP addresses" -ForegroundColor Yellow
    Read-Host "Press Enter to exit"
    exit 1
}

# CRITICAL FIX: Ensure we pass a proper array to jobs
Write-Host "DEBUG: Preparing final server list for jobs..." -ForegroundColor Yellow
$finalServerArray = @()
foreach ($server in $validVCenterServers) {
    $finalServerArray += $server
    Write-Host "  → Will pass to jobs: '$server'" -ForegroundColor Green
}

Write-Host "DEBUG: Final server array has $($finalServerArray.Count) entries" -ForegroundColor Yellow

$connectedServers = @()

Write-Host "Attempting to connect to vCenter servers..." -ForegroundColor Yellow
foreach ($vc in $validVCenterServers) {
    Write-Host "Connecting to $vc..." -ForegroundColor Gray
    try {
        Connect-VIServer -Server $vc -Credential $Credential -ErrorAction Stop
        Write-Host "Connected to $vc" -ForegroundColor Green
        $connectedServers += $vc
    } catch {
        Write-Warning "Failed to connect to $vc : $($_.Exception.Message)"
    }
}

if ($connectedServers.Count -eq 0) {
    Write-Error "Failed to connect to any vCenter servers"
    Read-Host "Press Enter to exit"
    exit 1
}

Write-Host "Successfully connected to $($connectedServers.Count) vCenter server(s)" -ForegroundColor Green

# Display confirmation
Write-Host "`n" + "=" * 80 -ForegroundColor Yellow
Write-Host "VM CONFIGURATION CHANGE CONFIRMATION" -ForegroundColor Yellow
Write-Host "=" * 80 -ForegroundColor Yellow

foreach ($vmEntry in $VMList) {
    Write-Host "VM: $($vmEntry.VMName) | CPU: $($vmEntry.CPUCountBefore) -> $($vmEntry.CPUCountAfter) | Hot Add: Enabled" -ForegroundColor Cyan
}

Write-Host "`nTotal VMs: $($VMList.Count) | Processing: PARALLEL" -ForegroundColor Yellow
Write-Host "WARNING: VMs will be shut down and reconfigured!" -ForegroundColor Red
Write-Host "`nPress ENTER to continue or CTRL+C to cancel..." -ForegroundColor White
Read-Host

# Create robust script block for parallel processing with FIXES
$vmProcessingScript = {
    param($vmData, $vCenterList, $username, $password, $jobId)
    
    # Create a unique log identifier
    $logPrefix = "[$($vmData.VMName)][Job$jobId]"
    $progressLog = @()
    
    function Add-ProgressLog {
        param($Message, $LogLevel = "INFO")
        $timestamp = Get-Date -Format "HH:mm:ss.fff"
        $logEntry = "$timestamp $logPrefix [$LogLevel] $Message"
        $script:progressLog += $logEntry
        
        # Create structured output for console processing
        $output = [PSCustomObject]@{
            Type = "ProgressUpdate"
            VMName = $vmData.VMName
            JobId = $jobId
            Timestamp = $timestamp
            LogLevel = $LogLevel
            Message = $Message
            FullLogEntry = $logEntry
        }
        Write-Output $output
    }
    
    try {
        Add-ProgressLog "STARTING - Initializing job environment" "START"
        
        # Recreate credential securely
        $securePassword = ConvertTo-SecureString -String $password -AsPlainText -Force
        $jobCredential = New-Object System.Management.Automation.PSCredential($username, $securePassword)
        
        # Import PowerCLI with complete banner suppression
        $moduleLoaded = $false
        $retryCount = 0
        
        # Redirect all output streams to suppress banner
        $originalVerbosePreference = $VerbosePreference
        $originalInformationPreference = $InformationPreference
        $originalWarningPreference = $WarningPreference
        
        $VerbosePreference = "SilentlyContinue"
        $InformationPreference = "SilentlyContinue" 
        $WarningPreference = "SilentlyContinue"
        
        while (-not $moduleLoaded -and $retryCount -lt 3) {
            try {
                # Completely suppress all output during module import
                $null = Import-Module VMware.PowerCLI -Force -Global -ErrorAction Stop -WarningAction SilentlyContinue -InformationAction SilentlyContinue -Verbose:$false 6>$null 3>$null 2>$null
                
                # Set all PowerCLI configurations immediately to suppress any remaining messages
                $null = Set-PowerCLIConfiguration -InvalidCertificateAction Ignore -Confirm:$false -Scope Session -ErrorAction SilentlyContinue -WarningAction SilentlyContinue -InformationAction SilentlyContinue -Verbose:$false 6>$null 3>$null 2>$null
                $null = Set-PowerCLIConfiguration -DisplayDeprecationWarnings $false -Confirm:$false -Scope Session -ErrorAction SilentlyContinue -WarningAction SilentlyContinue -InformationAction SilentlyContinue -Verbose:$false 6>$null 3>$null 2>$null
                $null = Set-PowerCLIConfiguration -ParticipateInCEIP $false -Confirm:$false -Scope Session -ErrorAction SilentlyContinue -WarningAction SilentlyContinue -InformationAction SilentlyContinue -Verbose:$false 6>$null 3>$null 2>$null
                $null = Set-PowerCLIConfiguration -DefaultVIServerMode Single -Confirm:$false -Scope Session -ErrorAction SilentlyContinue -WarningAction SilentlyContinue -InformationAction SilentlyContinue -Verbose:$false 6>$null 3>$null 2>$null
                $null = Set-PowerCLIConfiguration -WebOperationTimeoutSeconds 300 -Confirm:$false -Scope Session -ErrorAction SilentlyContinue -WarningAction SilentlyContinue -InformationAction SilentlyContinue -Verbose:$false 6>$null 3>$null 2>$null
                
                $moduleLoaded = $true
                Add-ProgressLog "INITIALIZED - PowerCLI loaded successfully (banner completely suppressed)" "SUCCESS"
            } catch {
                if (Get-Module -ListAvailable -Name VMware.VimAutomation.Core) {
                    try {
                        # Try legacy module import with complete suppression
                        $null = Import-Module VMware.VimAutomation.Core -Force -Global -ErrorAction Stop -WarningAction SilentlyContinue -InformationAction SilentlyContinue -Verbose:$false 6>$null 3>$null 2>$null
                        $null = Import-Module VMware.VimAutomation.Common -Force -Global -ErrorAction SilentlyContinue -WarningAction SilentlyContinue -InformationAction SilentlyContinue -Verbose:$false 6>$null 3>$null 2>$null
                        
                        # Set configurations with complete suppression
                        $null = Set-PowerCLIConfiguration -InvalidCertificateAction Ignore -Confirm:$false -Scope Session -ErrorAction SilentlyContinue -WarningAction SilentlyContinue -InformationAction SilentlyContinue -Verbose:$false 6>$null 3>$null 2>$null
                        $null = Set-PowerCLIConfiguration -DisplayDeprecationWarnings $false -Confirm:$false -Scope Session -ErrorAction SilentlyContinue -WarningAction SilentlyContinue -InformationAction SilentlyContinue -Verbose:$false 6>$null 3>$null 2>$null
                        $null = Set-PowerCLIConfiguration -ParticipateInCEIP $false -Confirm:$false -Scope Session -ErrorAction SilentlyContinue -WarningAction SilentlyContinue -InformationAction SilentlyContinue -Verbose:$false 6>$null 3>$null 2>$null
                        $null = Set-PowerCLIConfiguration -DefaultVIServerMode Single -Confirm:$false -Scope Session -ErrorAction SilentlyContinue -WarningAction SilentlyContinue -InformationAction SilentlyContinue -Verbose:$false 6>$null 3>$null 2>$null
                        
                        $moduleLoaded = $true
                        Add-ProgressLog "INITIALIZED - PowerCLI legacy modules loaded (banner completely suppressed)" "SUCCESS"
                    } catch {
                        $retryCount++
                        Add-ProgressLog "MODULE_RETRY - Legacy import attempt $retryCount failed: $($_.Exception.Message)" "WARN"
                        Start-Sleep -Seconds 2
                    }
                } else {
                    throw "PowerCLI modules not found"
                }
            }
        }
        
        # Restore original preference variables
        $VerbosePreference = $originalVerbosePreference
        $InformationPreference = $originalInformationPreference
        $WarningPreference = $originalWarningPreference
        
        if (-not $moduleLoaded) {
            throw "Failed to load PowerCLI after 3 attempts"
        }
        
        # Initialize result object
        $result = [PSCustomObject]@{
            Type = "FinalResult"
            VMName = $vmData.VMName
            JobId = $jobId
            Status = "Success"
            OriginalPowerState = $vmData.PowerState
            OriginalCPUCount = $vmData.CPUCountBefore
            TargetCPUCount = $vmData.CPUCountAfter
            NewCPUCount = ""
            NewCoresPerSocket = ""
            NewCPUHotAddEnabled = ""
            NewMemoryHotAddEnabled = ""
            FinalPowerState = ""
            ErrorMessage = ""
            StartTime = Get-Date
            EndTime = $null
            ProcessingTimeMinutes = 0
            ProgressLog = $progressLog
        }
        
        # FIXED: Connect to vCenter servers with enhanced validation and debugging
        Add-ProgressLog "CONNECTING - Attempting vCenter connections" "INFO"
        $jobConnections = @()
        $vmServer = $null
        
        # DEBUG: Show what we received in the job
        Add-ProgressLog "DEBUG - Received vCenter list count: $($vCenterList.Count)" "INFO"
        if ($vCenterList) {
            for ($i = 0; $i -lt $vCenterList.Count; $i++) {
                Add-ProgressLog "DEBUG - Server[$i]: '$($vCenterList[$i])'" "INFO"
            }
        }
        
        # Validate vCenter list is not empty and clean it thoroughly
        if (-not $vCenterList -or $vCenterList.Count -eq 0) {
            throw "vCenter server list is empty or null"
        }
        
        $validServers = @()
        foreach ($server in $vCenterList) {
            if (-not [string]::IsNullOrWhiteSpace($server) -and $server.Trim() -ne "" -and $server.Trim() -ne "test.test.test") {
                $cleanServer = $server.Trim()
                $validServers += $cleanServer
                Add-ProgressLog "VCENTER_VALID - Added server: '$cleanServer'" "INFO"
            } else {
                Add-ProgressLog "VCENTER_SKIP - Skipped invalid server: '$server'" "WARN"
            }
        }
        
        if ($validServers.Count -eq 0) {
            throw "No valid vCenter servers found after cleaning. Received servers: $($vCenterList -join ', ')"
        }
        
        Add-ProgressLog "VCENTER_LIST - Will attempt to connect to $($validServers.Count) servers: $($validServers -join ', ')" "INFO"
        
        foreach ($vcServer in $validServers) {
            try {
                Add-ProgressLog "CONNECT_ATTEMPT - Connecting to '$vcServer'" "INFO"
                
                # Additional validation before attempting connection
                if ([string]::IsNullOrWhiteSpace($vcServer) -or $vcServer -eq "test.test.test") {
                    Add-ProgressLog "CONNECT_SKIP - Invalid server name: '$vcServer'" "WARN"
                    continue
                }
                
                $connection = Connect-VIServer -Server $vcServer -Credential $jobCredential -ErrorAction Stop
                $jobConnections += $vcServer
                Add-ProgressLog "CONNECTED - Successfully connected to '$vcServer'" "SUCCESS"
                
                # Try to find VM immediately
                $testVM = Get-VM -Name $vmData.VMName -Server $vcServer -ErrorAction SilentlyContinue
                if ($testVM) {
                    Add-ProgressLog "VM_LOCATED - Found VM on $vcServer" "SUCCESS"
                    $vmServer = $vcServer
                    break
                }
            } catch {
                Add-ProgressLog "CONNECT_FAILED - $vcServer : $($_.Exception.Message)" "ERROR"
            }
        }
        
        if ($jobConnections.Count -eq 0) {
            throw "No vCenter connections established"
        }
        
        # Locate the VM with comprehensive error handling
        Add-ProgressLog "SEARCHING - Looking for VM across $($jobConnections.Count) connected servers" "INFO"
        $targetVM = $null
        
        # If we haven't found the VM yet, search all connected servers
        if (-not $vmServer) {
            foreach ($server in $jobConnections) {
                try {
                    $targetVM = Get-VM -Name $vmData.VMName -Server $server -ErrorAction Stop
                    if ($targetVM -and $targetVM.Name -eq $vmData.VMName) {
                        $vmServer = $server
                        Add-ProgressLog "VM_FOUND - Located '$($targetVM.Name)' on $server (Current Power: $($targetVM.PowerState), CPUs: $($targetVM.NumCpu))" "SUCCESS"
                        break
                    } else {
                        $targetVM = $null
                    }
                } catch {
                    Add-ProgressLog "VM_SEARCH - Not found on $server, continuing search..." "INFO"
                    $targetVM = $null
                }
            }
        } else {
            # Get the VM from the server we already identified
            $targetVM = Get-VM -Name $vmData.VMName -Server $vmServer -ErrorAction Stop
        }
        
        if (-not $targetVM -or -not $vmServer) {
            throw "VM '$($vmData.VMName)' not found on any connected vCenter server"
        }
        
        # Validate VM object before proceeding
        if (-not $targetVM.Name) {
            throw "VM object is invalid - Name property is missing"
        }
        
        # PHASE 1: Shutdown if needed with null checks
        if ($targetVM -and $targetVM.PowerState -eq "PoweredOn") {
            Add-ProgressLog "SHUTDOWN_START - Initiating graceful shutdown (VMware Tools required)" "INFO"
            
            try {
                Shutdown-VMGuest -VM $targetVM -Confirm:$false -ErrorAction Stop
                Add-ProgressLog "SHUTDOWN_INITIATED - Graceful shutdown command sent" "SUCCESS"
            } catch {
                Add-ProgressLog "SHUTDOWN_FALLBACK - Graceful shutdown failed, will force power off: $($_.Exception.Message)" "WARN"
                Stop-VM -VM $targetVM -Confirm:$false -ErrorAction Stop
            }
            
            $shutdownTimeout = (Get-Date).AddMinutes(8)
            $shutdownStart = Get-Date
            
            while ($targetVM -and $targetVM.PowerState -ne "PoweredOff" -and (Get-Date) -lt $shutdownTimeout) {
                Start-Sleep -Seconds 10
                
                try {
                    $targetVM = Get-VM -Name $vmData.VMName -Server $vmServer -ErrorAction Stop
                    $elapsed = [math]::Round(((Get-Date) - $shutdownStart).TotalSeconds)
                    
                    if ($elapsed % 30 -eq 0) {
                        Add-ProgressLog "SHUTDOWN_WAIT - Shutdown in progress (${elapsed}s elapsed, State: $($targetVM.PowerState))" "INFO"
                    }
                } catch {
                    Add-ProgressLog "SHUTDOWN_ERROR - Failed to refresh VM status during shutdown" "WARN"
                    break
                }
            }
            
            # Force shutdown if still running
            if ($targetVM -and $targetVM.PowerState -ne "PoweredOff") {
                Add-ProgressLog "SHUTDOWN_FORCE - Timeout reached, forcing power off" "WARN"
                try {
                    Stop-VM -VM $targetVM -Confirm:$false -ErrorAction Stop
                    Start-Sleep -Seconds 5
                    $targetVM = Get-VM -Name $vmData.VMName -Server $vmServer -ErrorAction Stop
                } catch {
                    Add-ProgressLog "SHUTDOWN_FORCE_ERROR - Failed to force power off: $($_.Exception.Message)" "ERROR"
                }
            }
            
            if ($targetVM) {
                $shutdownDuration = [math]::Round(((Get-Date) - $shutdownStart).TotalSeconds)
                Add-ProgressLog "SHUTDOWN_COMPLETE - VM powered off (took ${shutdownDuration}s, Final State: $($targetVM.PowerState))" "SUCCESS"
            }
        } else {
            Add-ProgressLog "SHUTDOWN_SKIP - VM already powered off or invalid, proceeding to reconfiguration" "INFO"
        }
        
        # PHASE 2: FIXED - Reconfigure VM with enhanced error handling
        Add-ProgressLog "CONFIG_START - Beginning VM reconfiguration" "INFO"
        
        # Wait a moment after shutdown before reconfiguration
        Start-Sleep -Seconds 3
        
        # FIXED: Enhanced VM object retrieval with comprehensive validation
        $retryCount = 0
        $maxRetries = 3
        $vmView = $null
        
        while ($retryCount -lt $maxRetries -and -not $vmView) {
            try {
                Add-ProgressLog "CONFIG_RETRIEVE - Attempt $($retryCount + 1) to get VM object for reconfiguration" "INFO"
                
                # Get fresh VM object with comprehensive validation
                $targetVM = Get-VM -Name $vmData.VMName -Server $vmServer -ErrorAction Stop
                
                if (-not $targetVM) {
                    throw "VM object is null after retrieval"
                }
                
                if (-not $targetVM.Id -or [string]::IsNullOrEmpty($targetVM.Id)) {
                    throw "VM object missing valid ID property"
                }
                
                Add-ProgressLog "CONFIG_VM_OK - VM object retrieved successfully: $($targetVM.Name)" "SUCCESS"
                
                # Validate VM object properties before using with Get-View
                if ($targetVM.ExtensionData) {
                    Add-ProgressLog "CONFIG_VIEW - Getting VM View object for API calls" "INFO"
                    $vmView = Get-View -VIObject $targetVM -ErrorAction Stop
                    
                    if ($vmView -and $vmView.Config) {
                        Add-ProgressLog "CONFIG_VIEW_OK - VM View object retrieved successfully" "SUCCESS"
                        break
                    } else {
                        throw "VM View or Config object is null"
                    }
                } else {
                    Add-ProgressLog "CONFIG_EXTENSIONDATA - VM ExtensionData is null, refreshing VM object" "WARN"
                    # Try to refresh the VM object
                    Start-Sleep -Seconds 2
                    $targetVM = Get-VM -Name $vmData.VMName -Server $vmServer -ErrorAction Stop
                    
                    if ($targetVM -and $targetVM.ExtensionData) {
                        $vmView = Get-View -VIObject $targetVM -ErrorAction Stop
                        if ($vmView -and $vmView.Config) {
                            Add-ProgressLog "CONFIG_VIEW_OK - VM View object retrieved after refresh" "SUCCESS"
                            break
                        }
                    }
                    throw "VM ExtensionData is null after refresh, cannot create View"
                }
                
            } catch {
                $retryCount++
                Add-ProgressLog "CONFIG_RETRY - Attempt $retryCount failed: $($_.Exception.Message)" "WARN"
                
                if ($retryCount -lt $maxRetries) {
                    Add-ProgressLog "CONFIG_WAIT - Waiting 5 seconds before retry..." "INFO"
                    Start-Sleep -Seconds 5
                } else {
                    throw "Failed to get VM objects for reconfiguration after $maxRetries attempts: $($_.Exception.Message)"
                }
            }
        }
        
        if (-not $vmView) {
            throw "Could not obtain VM View object after $maxRetries attempts"
        }
        
        $targetCPUs = [int]$vmData.CPUCountAfter
        
        # Log current configuration
        Add-ProgressLog "CONFIG_CURRENT - Current: $($vmView.Config.Hardware.NumCPU) CPUs, $($vmView.Config.Hardware.NumCoresPerSocket) cores/socket" "INFO"
        Add-ProgressLog "CONFIG_CURRENT - Hot Add CPU: $($vmView.Config.CpuHotAddEnabled), Hot Add Memory: $($vmView.Config.MemoryHotAddEnabled)" "INFO"
        Add-ProgressLog "CONFIG_TARGET - Target: $targetCPUs CPUs, 1 core/socket, Hot Add enabled" "INFO"
        
        $configSpec = New-Object VMware.Vim.VirtualMachineConfigSpec
        $configSpec.NumCPUs = $targetCPUs
        $configSpec.NumCoresPerSocket = 1
        $configSpec.CpuHotAddEnabled = $true
        $configSpec.MemoryHotAddEnabled = $true
        
        Add-ProgressLog "CONFIG_APPLY - Submitting configuration changes to vSphere API..." "INFO"
        $reconfigStart = Get-Date
        
        try {
            # Start the reconfiguration task
            $task = $vmView.ReconfigVM($configSpec)
            Add-ProgressLog "CONFIG_TASK - Reconfiguration task submitted (Task ID: $($task.Value))" "INFO"
            
            # Monitor the task progress
            $taskInfo = Get-View $task -ErrorAction Stop
            $timeout = (Get-Date).AddMinutes(10)  # 10 minute timeout for reconfig
            
            while ($taskInfo.Info.State -eq "running" -and (Get-Date) -lt $timeout) {
                Start-Sleep -Seconds 5
                try {
                    $taskInfo.UpdateViewData()
                    $elapsed = [math]::Round(((Get-Date) - $reconfigStart).TotalSeconds)
                    
                    # Log progress every 15 seconds
                    if ($elapsed % 15 -eq 0) {
                        Add-ProgressLog "CONFIG_PROGRESS - Reconfiguration in progress (${elapsed}s elapsed, State: $($taskInfo.Info.State))" "INFO"
                        
                        # Check if there's any progress info
                        if ($taskInfo.Info.Progress -ne $null) {
                            Add-ProgressLog "CONFIG_PROGRESS - Task progress: $($taskInfo.Info.Progress)%" "INFO"
                        }
                    }
                } catch {
                    Add-ProgressLog "CONFIG_MONITOR_ERROR - Error monitoring task: $($_.Exception.Message)" "WARN"
                    break
                }
            }
            
            # Check final task state
            try {
                $taskInfo.UpdateViewData()
                $reconfigDuration = [math]::Round(((Get-Date) - $reconfigStart).TotalSeconds)
                
                if ($taskInfo.Info.State -eq "success") {
                    Add-ProgressLog "CONFIG_COMPLETE - VM reconfiguration successful (took ${reconfigDuration}s)" "SUCCESS"
                } elseif ($taskInfo.Info.State -eq "error") {
                    $errorMsg = if ($taskInfo.Info.Error) { $taskInfo.Info.Error.LocalizedMessage } else { "Unknown error" }
                    throw "Reconfiguration failed: $errorMsg"
                } else {
                    Add-ProgressLog "CONFIG_TIMEOUT - Reconfiguration task timed out after ${reconfigDuration}s (State: $($taskInfo.Info.State))" "WARN"
                    # Don't throw error, continue and see if changes were applied
                }
            } catch {
                Add-ProgressLog "CONFIG_CHECK_ERROR - Error checking final task state: $($_.Exception.Message)" "WARN"
            }
            
        } catch {
            Add-ProgressLog "CONFIG_ERROR - Reconfiguration failed: $($_.Exception.Message)" "ERROR"
            throw $_
        }
        
        # PHASE 3: Power on based on original state - SIMPLIFIED VERSION
Add-ProgressLog "POWERON_CHECK - Original power state from CSV: '$($vmData.PowerState)'" "INFO"

# SIMPLIFIED LOGIC: Just power on the VM after reconfiguration
# Remove complex pattern matching and just power on
Add-ProgressLog "POWERON_DECISION - Powering on VM after reconfiguration (simplified logic)" "INFO"

Add-ProgressLog "POWERON_START - Initiating startup sequence" "INFO"

# Wait a moment after reconfiguration before powering on
Start-Sleep -Seconds 2

# SIMPLIFIED: Get fresh VM object and power it on
$powerOnRetries = 0
$maxPowerOnRetries = 3
$powerOnSuccess = $false

while ($powerOnRetries -lt $maxPowerOnRetries -and -not $powerOnSuccess) {
    try {
        Add-ProgressLog "POWERON_GET_VM - Attempt $($powerOnRetries + 1) to get VM for power operations" "INFO"
        $targetVM = Get-VM -Name $vmData.VMName -Server $vmServer -ErrorAction Stop
        
        if (-not $targetVM) {
            throw "Cannot retrieve VM object for power operations"
        }
        
        Add-ProgressLog "POWERON_VM_STATE - Current VM state: $($targetVM.PowerState)" "INFO"
        
        if ($targetVM.PowerState -eq "PoweredOff") {
            Add-ProgressLog "POWERON_EXECUTE - VM is PoweredOff, starting power on sequence" "INFO"
            
            # Start the VM
            $powerOnTask = Start-VM -VM $targetVM -Confirm:$false -RunAsync -ErrorAction Stop
            Add-ProgressLog "POWERON_INITIATED - Power on task started successfully" "SUCCESS"
            
            # Monitor power on progress
            $powerOnTimeout = (Get-Date).AddMinutes(10)
            $powerOnStart = Get-Date
            
            while ($targetVM.PowerState -ne "PoweredOn" -and (Get-Date) -lt $powerOnTimeout) {
                Start-Sleep -Seconds 10
                try {
                    $targetVM = Get-VM -Name $vmData.VMName -Server $vmServer -ErrorAction Stop
                    if ($targetVM) {
                        $elapsed = [math]::Round(((Get-Date) - $powerOnStart).TotalSeconds)
                        
                        if ($elapsed % 30 -eq 0 -or $elapsed -in @(10, 20)) {
                            Add-ProgressLog "POWERON_WAIT - VM starting up (${elapsed}s elapsed, Current State: $($targetVM.PowerState))" "INFO"
                        }
                        
                        # Check if VM is now powered on
                        if ($targetVM.PowerState -eq "PoweredOn") {
                            $powerOnSuccess = $true
                            break
                        }
                    }
                } catch {
                    Add-ProgressLog "POWERON_STATUS_ERROR - Error checking power status: $($_.Exception.Message)" "WARN"
                    break
                }
            }
            
            # Final power state check
            try {
                $targetVM = Get-VM -Name $vmData.VMName -Server $vmServer -ErrorAction Stop
                $powerOnDuration = [math]::Round(((Get-Date) - $powerOnStart).TotalSeconds)
                
                if ($targetVM -and $targetVM.PowerState -eq "PoweredOn") {
                    Add-ProgressLog "POWERON_COMPLETE - VM powered on successfully (took ${powerOnDuration}s)" "SUCCESS"
                    $powerOnSuccess = $true
                } else {
                    Add-ProgressLog "POWERON_TIMEOUT - VM did not fully start within timeout (${powerOnDuration}s, Final State: $($targetVM.PowerState))" "WARN"
                    
                    # If we're on the last retry, don't retry again
                    if ($powerOnRetries -eq $maxPowerOnRetries - 1) {
                        Add-ProgressLog "POWERON_FINAL_ATTEMPT - This was the final power-on attempt" "WARN"
                        break
                    }
                }
            } catch {
                Add-ProgressLog "POWERON_FINAL_CHECK_ERROR - Error during final power state check: $($_.Exception.Message)" "WARN"
            }
            
        } elseif ($targetVM.PowerState -eq "PoweredOn") {
            Add-ProgressLog "POWERON_ALREADY - VM is already powered on" "SUCCESS"
            $powerOnSuccess = $true
        } else {
            Add-ProgressLog "POWERON_UNEXPECTED_STATE - VM is in unexpected state: $($targetVM.PowerState)" "WARN"
            # Try to power on anyway
            try {
                Start-VM -VM $targetVM -Confirm:$false -ErrorAction Stop
                Add-ProgressLog "POWERON_FORCED - Attempted to power on from unexpected state" "INFO"
                Start-Sleep -Seconds 5
                $targetVM = Get-VM -Name $vmData.VMName -Server $vmServer -ErrorAction Stop
                if ($targetVM.PowerState -eq "PoweredOn") {
                    $powerOnSuccess = $true
                }
            } catch {
                Add-ProgressLog "POWERON_FORCE_FAILED - Failed to power on from unexpected state: $($_.Exception.Message)" "WARN"
            }
        }
        
        # If we got here without error and didn't succeed, increment retry counter
        if (-not $powerOnSuccess) {
            $powerOnRetries++
            if ($powerOnRetries -lt $maxPowerOnRetries) {
                Add-ProgressLog "POWERON_RETRY - Power on attempt $powerOnRetries failed, will retry..." "WARN"
                Start-Sleep -Seconds 5
            }
        }
        
    } catch {
        $powerOnRetries++
        Add-ProgressLog "POWERON_ERROR - Power on attempt $powerOnRetries failed: $($_.Exception.Message)" "ERROR"
        
        if ($powerOnRetries -lt $maxPowerOnRetries) {
            Add-ProgressLog "POWERON_RETRY_WAIT - Waiting 5 seconds before retry..." "INFO"
            Start-Sleep -Seconds 5
        }
    }
}

if (-not $powerOnSuccess) {
    Add-ProgressLog "POWERON_FAILED - Failed to power on VM after $maxPowerOnRetries attempts" "ERROR"
}           
        } else {
            Add-ProgressLog "POWERON_SKIP - VM original state was '$($vmData.PowerState)', leaving it powered off" "INFO"
        }
        
        # PHASE 4: Verify and finalize with enhanced error handling
        Add-ProgressLog "VERIFY_START - Checking final configuration" "INFO"
        
        # Re-get the VM object after reconfiguration with comprehensive error handling
        $targetVM = $null
        $finalVmView = $null
        
        try {
            $targetVM = Get-VM -Name $vmData.VMName -Server $vmServer -ErrorAction Stop
            if ($targetVM -and $targetVM.Id) {
                $finalVmView = Get-View -VIObject $targetVM -ErrorAction Stop
                Add-ProgressLog "VERIFY_SUCCESS - Successfully retrieved updated VM configuration" "SUCCESS"
            } else {
                Add-ProgressLog "VERIFY_ERROR - VM object or VM ID is invalid after reconfiguration" "ERROR"
            }
        } catch {
            Add-ProgressLog "VERIFY_ERROR - Failed to get updated VM info: $($_.Exception.Message)" "ERROR"
            # Try to get basic info without View
            try {
                $targetVM = Get-VM -Name $vmData.VMName -Server $vmServer -ErrorAction Stop
                Add-ProgressLog "VERIFY_PARTIAL - Got basic VM info without View" "WARN"
            } catch {
                Add-ProgressLog "VERIFY_CRITICAL - Cannot retrieve VM object at all" "ERROR"
            }
        }
        
        # Update result with final configuration if available
        if ($finalVmView) {
            $result.NewCPUCount = $finalVmView.Config.Hardware.NumCPU
            $result.NewCoresPerSocket = $finalVmView.Config.Hardware.NumCoresPerSocket
            $result.NewCPUHotAddEnabled = $finalVmView.Config.CpuHotAddEnabled
            $result.NewMemoryHotAddEnabled = $finalVmView.Config.MemoryHotAddEnabled
            
            Add-ProgressLog "FINAL_CONFIG - CPUs: $($result.NewCPUCount), Cores/Socket: $($result.NewCoresPerSocket)" "SUCCESS"
            Add-ProgressLog "VERIFICATION - Hot Add CPU: $($result.NewCPUHotAddEnabled), Hot Add Memory: $($result.NewMemoryHotAddEnabled)" "SUCCESS"
        } else {
            # Fallback - use target values
            $result.NewCPUCount = $targetCPUs
            $result.NewCoresPerSocket = 1
            $result.NewCPUHotAddEnabled = $true
            $result.NewMemoryHotAddEnabled = $true
            Add-ProgressLog "FINAL_CONFIG - Using target values (verification failed)" "WARN"
        }
        
        if ($targetVM) {
            $result.FinalPowerState = $targetVM.PowerState
            Add-ProgressLog "FINAL_POWER_STATE - $($result.FinalPowerState)" "INFO"
        } else {
            $result.FinalPowerState = "Unknown"
            Add-ProgressLog "FINAL_POWER_STATE - Unknown (VM object unavailable)" "WARN"
        }
        
        $result.EndTime = Get-Date
        $result.ProcessingTimeMinutes = [math]::Round(($result.EndTime - $result.StartTime).TotalMinutes, 2)
        
        Add-ProgressLog "SUCCESS - Processing completed in $($result.ProcessingTimeMinutes) minutes" "SUCCESS"
        
        # Cleanup connections
        foreach ($server in $jobConnections) {
            try {
                Disconnect-VIServer -Server $server -Confirm:$false -Force -ErrorAction SilentlyContinue
                Add-ProgressLog "CLEANUP - Disconnected from $server" "INFO"
            } catch {
                # Ignore cleanup errors
            }
        }
        
    } catch {
        $result.Status = "Failed"
        $result.ErrorMessage = $_.Exception.Message
        $result.EndTime = Get-Date
        if ($result.StartTime) {
            $result.ProcessingTimeMinutes = [math]::Round(($result.EndTime - $result.StartTime).TotalMinutes, 2)
        }
        Add-ProgressLog "FAILED - $($_.Exception.Message)" "ERROR"
        
        # Cleanup connections on failure
        try {
            $failedJobConnections = Get-VIServer -ErrorAction SilentlyContinue
            foreach ($server in $failedJobConnections) {
                try {
                    Disconnect-VIServer -Server $server -Confirm:$false -Force -ErrorAction SilentlyContinue
                } catch {
                    # Ignore cleanup errors
                }
            }
        } catch {
            # Ignore cleanup errors
        }
    }
    
    # Always include the progress log in the result
    $result.ProgressLog = $progressLog
    
    # Return the result object
    Write-Output $result
}

# Extract credentials for job parameters
$Username = $Credential.UserName
$Password = $Credential.GetNetworkCredential().Password

# Start parallel processing with enhanced monitoring
Write-Host "`n" + "=" * 80 -ForegroundColor Cyan
Write-Host "STARTING PARALLEL PROCESSING" -ForegroundColor Cyan
Write-Host "=" * 80 -ForegroundColor Cyan
Write-Host "Maximum concurrent jobs: 4" -ForegroundColor Yellow
Write-Host "Real-time monitoring enabled" -ForegroundColor Yellow

$jobs = @()
$maxJobs = 4
$jobCounter = 1
$scriptStartTime = Get-Date

# Job tracking arrays
$results = @()
$processedJobs = @()
$jobStatus = @{}

# FIXED: Start jobs in batches with validated server list
foreach ($vmEntry in $VMList) {
    # Wait for available slot
    while ((Get-Job -State Running).Count -ge $maxJobs) {
        Start-Sleep -Seconds 1
        
        # Process real-time updates from running jobs
        $runningJobs = Get-Job -State Running
        foreach ($runningJob in $runningJobs) {
            $updates = Receive-Job -Job $runningJob -Keep | Where-Object { $_.Type -eq "ProgressUpdate" }
            foreach ($update in $updates) {
                if (-not $jobStatus.ContainsKey($update.JobId)) {
                    $jobStatus[$update.JobId] = @()
                }
                
                # Only show new updates
                if ($jobStatus[$update.JobId] -notcontains $update.FullLogEntry) {
                    $jobStatus[$update.JobId] += $update.FullLogEntry
                    
                    # Color code based on log level
                    $color = switch ($update.LogLevel) {
                        "START" { "Cyan" }
                        "SUCCESS" { "Green" }
                        "ERROR" { "Red" }
                        "WARN" { "Yellow" }
                        default { "Gray" }
                    }
                    
                    Write-Host $update.FullLogEntry -ForegroundColor $color
                }
            }
        }
        
        # Check for completed jobs
        $completedJobs = Get-Job | Where-Object { $_.State -ne 'Running' -and $_.Id -notin $processedJobs }
        foreach ($completedJob in $completedJobs) {
            $jobInfo = $jobs | Where-Object { $_.Job.Id -eq $completedJob.Id }
            if ($jobInfo) {
                Write-Host "`n>>> PROCESSING COMPLETED JOB FOR VM: $($jobInfo.VMName) <<<" -ForegroundColor Magenta
                
                try {
                    $jobOutput = Receive-Job -Job $completedJob -ErrorAction Stop
                    $vmResult = $jobOutput | Where-Object { $_.Type -eq "FinalResult" } | Select-Object -Last 1
                    
                    if ($vmResult) {
                        $results += $vmResult
                        $duration = [math]::Round(((Get-Date) - $jobInfo.StartTime).TotalMinutes, 2)
                        
                        if ($vmResult.Status -eq "Success") {
                            Write-Host "✓ SUCCESS: $($vmResult.VMName)" -ForegroundColor Green
                            Write-Host "  └─ Configuration: $($vmResult.NewCPUCount) CPUs, $($vmResult.NewCoresPerSocket) cores/socket" -ForegroundColor Green
                            Write-Host "  └─ Power State: $($vmResult.FinalPowerState)" -ForegroundColor Green
                            Write-Host "  └─ Processing Time: $duration minutes" -ForegroundColor Green
                        } else {
                            Write-Host "✗ FAILED: $($vmResult.VMName)" -ForegroundColor Red
                            Write-Host "  └─ Error: $($vmResult.ErrorMessage)" -ForegroundColor Red
                            Write-Host "  └─ Processing Time: $duration minutes" -ForegroundColor Red
                        }
                    } else {
                        Write-Warning "Could not extract result for VM: $($jobInfo.VMName)"
                    }
                } catch {
                    Write-Warning "Error processing job $($completedJob.Id): $_"
                }
                
                Remove-Job -Job $completedJob -Force
                $processedJobs += $completedJob.Id
                
                Write-Host ">>> JOB PROCESSING COMPLETE <<<`n" -ForegroundColor Magenta
            }
        }
    }
    
    # FIXED: Start new job with properly formatted server array
    Write-Host "DEBUG: Starting job with server array: $($finalServerArray -join ', ')" -ForegroundColor Gray
    $job = Start-Job -ScriptBlock $vmProcessingScript -ArgumentList $vmEntry, $finalServerArray, $Username, $Password, $jobCounter
    $jobs += [PSCustomObject]@{
        Job = $job
        VMName = $vmEntry.VMName 
        JobId = $jobCounter
        StartTime = Get-Date
    }
    
    Write-Host "`nLAUNCHED JOB $jobCounter FOR VM: $($vmEntry.VMName)" -ForegroundColor Cyan -BackgroundColor DarkBlue
    Write-Host "   PowerShell Job ID: $($job.Id) | Target CPUs: $($vmEntry.CPUCountBefore) → $($vmEntry.CPUCountAfter)" -ForegroundColor White
    $jobCounter++
    
    # Small delay to prevent overwhelming the system
    Start-Sleep -Seconds 1
}

Write-Host "`n" + "=" * 80 -ForegroundColor Green
Write-Host "ALL JOBS LAUNCHED - MONITORING PROGRESS" -ForegroundColor Green
Write-Host "=" * 80 -ForegroundColor Green
Write-Host "Active PowerShell jobs: $((Get-Job -State Running).Count)" -ForegroundColor Yellow

# Enhanced job monitoring with comprehensive real-time updates
$lastSummaryUpdate = Get-Date

while ($jobs.Count -gt $processedJobs.Count) {
    # Process real-time updates from all running jobs
    $runningJobs = Get-Job -State Running
    foreach ($runningJob in $runningJobs) {
        $updates = Receive-Job -Job $runningJob -Keep | Where-Object { $_.Type -eq "ProgressUpdate" }
        foreach ($update in $updates) {
            if (-not $jobStatus.ContainsKey($update.JobId)) {
                $jobStatus[$update.JobId] = @()
            }
            
            # Only show new updates
            if ($jobStatus[$update.JobId] -notcontains $update.FullLogEntry) {
                $jobStatus[$update.JobId] += $update.FullLogEntry
                
                # Color code and add visual indicators based on log level
                $indicator = switch ($update.LogLevel) {
                    "START" { "[START]" }
                    "SUCCESS" { "[SUCCESS]" }
                    "ERROR" { "[ERROR]" }
                    "WARN" { "[WARN]" }
                    default { "[INFO]" }
                }
                
                $color = switch ($update.LogLevel) {
                    "START" { "Cyan" }
                    "SUCCESS" { "Green" }
                    "ERROR" { "Red" }
                    "WARN" { "Yellow" }
                    default { "Gray" }
                }
                
                Write-Host "$indicator $($update.FullLogEntry)" -ForegroundColor $color
            }
        }
    }
    
    # Check for completed jobs
    $completedJobs = Get-Job | Where-Object { $_.State -ne 'Running' -and $_.Id -notin $processedJobs }
    foreach ($completedJob in $completedJobs) {
        $jobInfo = $jobs | Where-Object { $_.Job.Id -eq $completedJob.Id }
        if ($jobInfo) {
            Write-Host "`n" + "=" * 50 -ForegroundColor Magenta
            Write-Host "PROCESSING COMPLETED JOB FOR VM: $($jobInfo.VMName)" -ForegroundColor Magenta -BackgroundColor DarkMagenta
            Write-Host "=" * 50 -ForegroundColor Magenta
            
            try {
                $jobOutput = Receive-Job -Job $completedJob -ErrorAction Stop
                $vmResult = $jobOutput | Where-Object { $_.Type -eq "FinalResult" } | Select-Object -Last 1
                
                if ($vmResult) {
                    $results += $vmResult
                    $duration = [math]::Round(((Get-Date) - $jobInfo.StartTime).TotalMinutes, 2)
                    
                    if ($vmResult.Status -eq "Success") {
                        Write-Host "*** SUCCESS: $($vmResult.VMName)" -ForegroundColor Green -BackgroundColor DarkGreen
                        Write-Host "    Configuration: $($vmResult.OriginalCPUCount) -> $($vmResult.NewCPUCount) CPUs, $($vmResult.NewCoresPerSocket) cores/socket" -ForegroundColor Green
                        Write-Host "    Power State: $($vmResult.FinalPowerState)" -ForegroundColor Green
                        Write-Host "    Hot Add CPU: $($vmResult.NewCPUHotAddEnabled) | Hot Add Memory: $($vmResult.NewMemoryHotAddEnabled)" -ForegroundColor Green
                        Write-Host "    Processing Time: $duration minutes" -ForegroundColor Green
                    } else {
                        Write-Host "*** FAILURE: $($vmResult.VMName)" -ForegroundColor Red -BackgroundColor DarkRed
                        Write-Host "    Error: $($vmResult.ErrorMessage)" -ForegroundColor Red
                        Write-Host "    Processing Time: $duration minutes" -ForegroundColor Red
                    }
                } else {
                    Write-Warning "Could not extract result for VM: $($jobInfo.VMName)"
                }
            } catch {
                Write-Warning "Error processing job $($completedJob.Id): $_"
            }
            
            Remove-Job -Job $completedJob -Force
            $processedJobs += $completedJob.Id
            
            Write-Host "=" * 50 -ForegroundColor Magenta
            Write-Host ""
        }
    }
    
    # Comprehensive status update every 20 seconds
    if (((Get-Date) - $lastSummaryUpdate).TotalSeconds -ge 20) {
        $completed = $processedJobs.Count
        $running = $runningJobs.Count
        $total = $jobs.Count
        $elapsedTotal = [math]::Round(((Get-Date) - $scriptStartTime).TotalMinutes, 1)
        
        Write-Host "`n" + "=" * 30 -ForegroundColor Yellow
        Write-Host "COMPREHENSIVE STATUS UPDATE - $elapsedTotal minutes elapsed" -ForegroundColor Yellow -BackgroundColor DarkYellow
        Write-Host "=" * 30 -ForegroundColor Yellow
        Write-Host "Completed: $completed/$total" -ForegroundColor Green
        Write-Host "Running: $running" -ForegroundColor Cyan
        Write-Host "Remaining: $($total - $completed)" -ForegroundColor Yellow
        Write-Host "Success Rate: $([math]::Round(($results | Where-Object {$_.Status -eq 'Success'}).Count / [math]::Max($completed, 1) * 100, 1))%" -ForegroundColor Green
        
        if ($running -gt 0) {
            Write-Host "`nCURRENTLY PROCESSING:" -ForegroundColor Cyan
            $runningJobsInfo = $jobs | Where-Object { $_.Job.Id -in $runningJobs.Id }
            foreach ($runningJob in $runningJobsInfo) {
                $elapsed = [math]::Round(((Get-Date) - $runningJob.StartTime).TotalMinutes, 1)
                Write-Host "   • $($runningJob.VMName) (Job $($runningJob.JobId) - ${elapsed}m)" -ForegroundColor White
            }
        }
        
        Write-Host "=" * 30 -ForegroundColor Yellow
        Write-Host ""
        
        $lastSummaryUpdate = Get-Date
    }
    
    Start-Sleep -Seconds 2
}

# Final processing and comprehensive reporting
$totalScriptTime = [math]::Round(((Get-Date) - $scriptStartTime).TotalMinutes, 2)

Write-Host "`n" + "=" * 80 -ForegroundColor Green
Write-Host "*** ALL JOBS COMPLETED - GENERATING COMPREHENSIVE FINAL REPORT ***" -ForegroundColor Green -BackgroundColor DarkGreen
Write-Host "=" * 80 -ForegroundColor Green

if ($results.Count -gt 0) {
    # Export detailed report
    $results | Export-Csv -Path $ReportPath -NoTypeInformation
    
    # Comprehensive summary statistics
    $successful = ($results | Where-Object { $_.Status -eq "Success" }).Count
    $failed = ($results | Where-Object { $_.Status -eq "Failed" }).Count
    $avgTime = if ($results.Count -gt 0) { [math]::Round(($results | Measure-Object ProcessingTimeMinutes -Average).Average, 2) } else { 0 }
    $maxTime = if ($results.Count -gt 0) { [math]::Round(($results | Measure-Object ProcessingTimeMinutes -Maximum).Maximum, 2) } else { 0 }
    $minTime = if ($results.Count -gt 0) { [math]::Round(($results | Measure-Object ProcessingTimeMinutes -Minimum).Minimum, 2) } else { 0 }
    
    Write-Host "`nCOMPREHENSIVE FINAL SUMMARY:" -ForegroundColor Cyan -BackgroundColor DarkCyan
    Write-Host "=" * 50 -ForegroundColor Cyan
    Write-Host "Total VMs Processed: $($results.Count)" -ForegroundColor Yellow
    Write-Host "Successful Operations: $successful" -ForegroundColor Green
    Write-Host "Failed Operations: $failed" -ForegroundColor Red
    Write-Host "Success Rate: $([math]::Round($successful / [math]::Max($results.Count, 1) * 100, 1))%" -ForegroundColor $(if ($successful -eq $results.Count) { "Green" } else { "Yellow" })
    Write-Host "Total Script Runtime: $totalScriptTime minutes" -ForegroundColor Yellow
    Write-Host "Average Processing Time per VM: $avgTime minutes" -ForegroundColor Yellow
    Write-Host "Fastest VM Processing: $minTime minutes" -ForegroundColor Green
    Write-Host "Slowest VM Processing: $maxTime minutes" -ForegroundColor Yellow
    Write-Host "Report File: $ReportPath" -ForegroundColor Cyan
    Write-Host "=" * 50 -ForegroundColor Cyan
    
    # Detailed results table
    Write-Host "`nDETAILED RESULTS TABLE:" -ForegroundColor Cyan
    $results | Select-Object VMName, Status, OriginalCPUCount, NewCPUCount, NewCoresPerSocket, FinalPowerState, ProcessingTimeMinutes | 
        Format-Table -AutoSize
    
    # Show failures if any
    $failures = $results | Where-Object { $_.Status -eq "Failed" }
    if ($failures) {
        Write-Host "`nFAILURE ANALYSIS:" -ForegroundColor Red -BackgroundColor DarkRed
        Write-Host "=" * 40 -ForegroundColor Red
        $failures | Select-Object VMName, ErrorMessage, ProcessingTimeMinutes | Format-Table -AutoSize -Wrap
    }
    
    # Performance analysis
    if ($results.Count -gt 1) {
        Write-Host "`nPERFORMANCE ANALYSIS:" -ForegroundColor Yellow
        Write-Host "=" * 30 -ForegroundColor Yellow
        
        $fastVMs = $results | Sort-Object ProcessingTimeMinutes | Select-Object -First 3
        $slowVMs = $results | Sort-Object ProcessingTimeMinutes -Descending | Select-Object -First 3
        
        Write-Host "Fastest Processing:" -ForegroundColor Green
        $fastVMs | Select-Object VMName, ProcessingTimeMinutes, Status | Format-Table -AutoSize
        
        Write-Host "Slowest Processing:" -ForegroundColor Yellow
        $slowVMs | Select-Object VMName, ProcessingTimeMinutes, Status | Format-Table -AutoSize
    }
    
} else {
    Write-Warning "No results collected! Check for job execution issues."
}

# Cleanup vCenter connections
Write-Host "`nCleaning up vCenter connections..." -ForegroundColor Yellow
foreach ($server in $connectedServers) {
    try {
        Disconnect-VIServer -Server $server -Confirm:$false -ErrorAction SilentlyContinue
        Write-Host "Disconnected from $server" -ForegroundColor Green
    } catch {
        Write-Warning "Failed to disconnect from $server"
    }
}

Write-Host "`nScript completed at: $(Get-Date)" -ForegroundColor Green
Write-Host "Total script runtime: $totalScriptTime minutes" -ForegroundColor Cyan
Write-Host "`nThank you for using the Enhanced VM Configuration Script!" -ForegroundColor Green

# Pause for user review
Write-Host "`nPress Enter to exit..." -ForegroundColor Yellow
Read-Host
