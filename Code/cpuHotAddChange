# VM Configuration Update Script
# This script processes a CSV file to update VM CPU and memory settings

# Specify the CSV file path here
$CSVPath = "C:\path\to\your\vmlist.csv"

# Specify the report file path here
$ReportPath = "C:\Reports\VM_Configuration_Report_$(Get-Date -Format 'yyyyMMdd_HHmmss').csv"

Write-Host "Starting VM Configuration Update Script..." -ForegroundColor Green
Write-Host "Script started at: $(Get-Date)" -ForegroundColor Gray

# Set PowerCLI configuration to ignore certificate warnings
Write-Host "Configuring PowerCLI settings..." -ForegroundColor Yellow
try {
    Set-PowerCLIConfiguration -InvalidCertificateAction Ignore -Confirm:$false -Scope Session
    Write-Host "PowerCLI configuration set successfully" -ForegroundColor Green
} catch {
    Write-Warning "Failed to set PowerCLI configuration: $($_.Exception.Message)"
}

# vCenter connection parameters
$vCenterServers = @(
    "test.test.test",
    "test.test.test", 
    "test.test.test",
    "test.test.test",
    "test.test.test"
)

Write-Host "Starting VM Configuration Update Process" -ForegroundColor Cyan
Write-Host "CSV File: $CSVPath" -ForegroundColor Yellow
Write-Host "Report will be saved to: $ReportPath" -ForegroundColor Yellow

# Validate CSV file exists
Write-Host "Checking CSV file..." -ForegroundColor Yellow
Write-Host "Looking for CSV at: $CSVPath" -ForegroundColor Gray

if (!(Test-Path $CSVPath)) {
    Write-Error "CSV file not found at path: $CSVPath"
    Write-Host "Please check the file path and ensure the file exists." -ForegroundColor Red
    Read-Host "Press Enter to exit"
    exit 1
}
Write-Host "CSV file found successfully" -ForegroundColor Green

# Read and validate CSV file
Write-Host "Reading CSV file..." -ForegroundColor Yellow
try {
    $VMList = Import-Csv -Path $CSVPath
    Write-Host "Successfully imported CSV with $($VMList.Count) VMs" -ForegroundColor Green
    
    if ($VMList.Count -eq 0) {
        Write-Error "CSV file is empty or contains no data rows"
        Read-Host "Press Enter to exit"
        exit 1
    }
} catch {
    Write-Error "Failed to import CSV file: $($_.Exception.Message)"
    Read-Host "Press Enter to exit"
    exit 1
}

# Validate CSV headers
Write-Host "Validating CSV headers..." -ForegroundColor Yellow
$requiredHeaders = @("VMName", "PowerState", "CPUHotAddEnabled", "MemoryHotAddEnabled", "CPUCountBefore", "CPUCountAfter")
$csvHeaders = $VMList[0].PSObject.Properties.Name
Write-Host "Found headers: $($csvHeaders -join ', ')" -ForegroundColor Gray

$missingHeaders = $requiredHeaders | Where-Object { $_ -notin $csvHeaders }

if ($missingHeaders) {
    Write-Error "Missing required CSV headers: $($missingHeaders -join ', ')"
    Write-Host "Required headers: $($requiredHeaders -join ', ')" -ForegroundColor Yellow
    Read-Host "Press Enter to exit"
    exit 1
}
Write-Host "CSV headers validated successfully" -ForegroundColor Green

# Connect to vCenter servers
Write-Host "Preparing to connect to vCenter servers..." -ForegroundColor Yellow
$Credential = Get-Credential -Message "Enter vCenter credentials"

if (!$Credential) {
    Write-Error "No credentials provided. Exiting."
    Read-Host "Press Enter to exit"
    exit 1
}

$connectedServers = @()

Write-Host "Attempting to connect to vCenter servers..." -ForegroundColor Yellow
foreach ($vc in $vCenterServers) {
    Write-Host "Connecting to $vc..." -ForegroundColor Gray
    try {
        Connect-VIServer -Server $vc -Credential $Credential -ErrorAction Stop
        Write-Host "Connected to $vc" -ForegroundColor Green
        $connectedServers += $vc
    } catch {
        Write-Warning "Failed to connect to $vc : $($_.Exception.Message)"
    }
}

if ($connectedServers.Count -eq 0) {
    Write-Error "Failed to connect to any vCenter servers"
    Write-Host "Please check your credentials and server connectivity." -ForegroundColor Red
    Read-Host "Press Enter to exit"
    exit 1
}

Write-Host "Successfully connected to $($connectedServers.Count) vCenter server(s)" -ForegroundColor Green

# Initialize report array
$report = @()

# Function to wait for VM to be fully powered off
function Wait-VMPowerOff {
    param([string]$VMName, [int]$TimeoutMinutes = 10)
    
    $timeout = (Get-Date).AddMinutes($TimeoutMinutes)
    do {
        Start-Sleep -Seconds 10
        $vm = Get-VM -Name $VMName -ErrorAction SilentlyContinue
        if ($vm.PowerState -eq "PoweredOff") {
            return $true
        }
        Write-Host "Waiting for $VMName to power off..." -ForegroundColor Yellow
    } while ((Get-Date) -lt $timeout)
    
    return $false
}

# Function to wait for VM to be fully powered on
function Wait-VMPowerOn {
    param([string]$VMName, [int]$TimeoutMinutes = 10)
    
    $timeout = (Get-Date).AddMinutes($TimeoutMinutes)
    do {
        Start-Sleep -Seconds 10
        $vm = Get-VM -Name $VMName -ErrorAction SilentlyContinue
        if ($vm.PowerState -eq "PoweredOn") {
            return $true
        }
        Write-Host "Waiting for $VMName to power on..." -ForegroundColor Yellow
    } while ((Get-Date) -lt $timeout)
    
    return $false
}

# Display VMs that will be processed and ask for confirmation
Write-Host "`n" -ForegroundColor White
Write-Host "=" * 80 -ForegroundColor Yellow
Write-Host "VM CONFIGURATION CHANGE CONFIRMATION" -ForegroundColor Yellow
Write-Host "=" * 80 -ForegroundColor Yellow
Write-Host "`nThe following VMs from your CSV will be modified:" -ForegroundColor Cyan
Write-Host ""

# Display each VM with its planned changes
foreach ($vmEntry in $VMList) {
    Write-Host "VM Name: $($vmEntry.VMName)" -ForegroundColor White
    Write-Host "  Current Power State: $($vmEntry.PowerState)" -ForegroundColor Gray
    Write-Host "  CPU Count: $($vmEntry.CPUCountBefore) -> $($vmEntry.CPUCountAfter)" -ForegroundColor Yellow
    Write-Host "  Cores per Socket: Will be set to 1" -ForegroundColor Yellow
    Write-Host "  CPU Hot Add: $($vmEntry.CPUHotAddEnabled) -> TRUE" -ForegroundColor Yellow
    Write-Host "  Memory Hot Add: $($vmEntry.MemoryHotAddEnabled) -> TRUE" -ForegroundColor Yellow
    Write-Host "  Actions: Shutdown -> Reconfigure -> Power On" -ForegroundColor Red
    Write-Host ""
}

Write-Host "Total VMs to be modified: $($VMList.Count)" -ForegroundColor Cyan
Write-Host ""
Write-Host "WARNING: These VMs will be shut down and reconfigured!" -ForegroundColor Red -BackgroundColor Black
Write-Host ""
Write-Host "Do you want to proceed with these changes?" -ForegroundColor Yellow
Write-Host "Press ENTER to continue or CTRL+C to cancel..." -ForegroundColor White

# Wait for user confirmation
Read-Host

Write-Host "`nProceeding with VM configuration changes..." -ForegroundColor Green
Write-Host "=" * 80 -ForegroundColor Green

# Process VMs in batch mode (parallel processing)
Write-Host "`nProcessing VMs in batch mode..." -ForegroundColor Green
Write-Host "=" * 80 -ForegroundColor Green

# Create script block for parallel VM processing
$vmProcessingScript = {
    param($vmEntry, $connectedServers)
    
    # Import PowerCLI in the background job
    Import-Module VMware.PowerCLI -ErrorAction SilentlyContinue
    
    $vmReport = [PSCustomObject]@{
        VMName = $vmEntry.VMName
        OriginalPowerState = $vmEntry.PowerState
        OriginalCPUHotAddEnabled = $vmEntry.CPUHotAddEnabled
        OriginalMemoryHotAddEnabled = $vmEntry.MemoryHotAddEnabled
        OriginalCPUCount = $vmEntry.CPUCountBefore
        TargetCPUCount = $vmEntry.CPUCountAfter
        NewCPUCount = ""
        NewCoresPerSocket = ""
        NewCPUHotAddEnabled = ""
        NewMemoryHotAddEnabled = ""
        FinalPowerState = ""
        Status = ""
        ErrorMessage = ""
        ProcessingThread = [System.Threading.Thread]::CurrentThread.ManagedThreadId
    }
    
    try {
        Write-Host "[Thread $([System.Threading.Thread]::CurrentThread.ManagedThreadId)] Processing VM: $($vmEntry.VMName)" -ForegroundColor Cyan
        
        # Find the specific VM from the CSV across all connected vCenters
        $vm = $null
        foreach ($server in $connectedServers) {
            $vm = Get-VM -Name $vmEntry.VMName -Server $server -ErrorAction SilentlyContinue
            if ($vm) {
                Write-Host "[Thread $([System.Threading.Thread]::CurrentThread.ManagedThreadId)] Found VM $($vmEntry.VMName) on server $server" -ForegroundColor Green
                break
            }
        }
        
        if (!$vm) {
            throw "VM '$($vmEntry.VMName)' from CSV not found on any connected vCenter server"
        }
        
        # Step 1: Shutdown VM if it's powered on
        if ($vm.PowerState -eq "PoweredOn") {
            Write-Host "[Thread $([System.Threading.Thread]::CurrentThread.ManagedThreadId)] Shutting down VM: $($vmEntry.VMName)" -ForegroundColor Yellow
            Shutdown-VMGuest -VM $vm -Confirm:$false
            
            # Wait for VM to be fully powered off
            $timeout = (Get-Date).AddMinutes(10)
            do {
                Start-Sleep -Seconds 10
                $vm = Get-VM -Name $vmEntry.VMName -ErrorAction SilentlyContinue
                if ($vm.PowerState -eq "PoweredOff") {
                    break
                }
                Write-Host "[Thread $([System.Threading.Thread]::CurrentThread.ManagedThreadId)] Waiting for $($vmEntry.VMName) to power off..." -ForegroundColor Yellow
            } while ((Get-Date) -lt $timeout)
            
            if ($vm.PowerState -ne "PoweredOff") {
                Write-Warning "[Thread $([System.Threading.Thread]::CurrentThread.ManagedThreadId)] VM did not shutdown gracefully, forcing power off"
                Stop-VM -VM $vm -Confirm:$false
                Start-Sleep -Seconds 30
            }
        }
        
        # Refresh VM object
        $vm = Get-VM -Name $vmEntry.VMName
        
        # Step 2: Get current CPU configuration
        $vmView = Get-View -VIObject $vm
        $currentCoresPerSocket = $vmView.Config.Hardware.NumCoresPerSocket
        $currentCPUCount = $vmView.Config.Hardware.NumCPU
        
        Write-Host "[Thread $([System.Threading.Thread]::CurrentThread.ManagedThreadId)] Current CPU Config - Count: $currentCPUCount, Cores per Socket: $currentCoresPerSocket" -ForegroundColor Yellow
        
        # Step 3: Configure CPU settings (1 core per socket, update CPU count)
        $targetCPUCount = [int]$vmEntry.CPUCountAfter
        Write-Host "[Thread $([System.Threading.Thread]::CurrentThread.ManagedThreadId)] Configuring CPU: Count=$targetCPUCount, Cores per Socket=1" -ForegroundColor Yellow
        
        $vmConfigSpec = New-Object VMware.Vim.VirtualMachineConfigSpec
        $vmConfigSpec.NumCPUs = $targetCPUCount
        $vmConfigSpec.NumCoresPerSocket = 1
        
        # Step 4: Enable CPU and Memory Hot Add
        $vmConfigSpec.CpuHotAddEnabled = $true
        $vmConfigSpec.MemoryHotAddEnabled = $true
        
        # Apply configuration changes
        $vmView.ReconfigVM($vmConfigSpec)
        Write-Host "[Thread $([System.Threading.Thread]::CurrentThread.ManagedThreadId)] Applied CPU and Hot Add configuration" -ForegroundColor Green
        
        # Step 5: Power on the VM
        Write-Host "[Thread $([System.Threading.Thread]::CurrentThread.ManagedThreadId)] Starting VM: $($vmEntry.VMName)" -ForegroundColor Yellow
        Start-VM -VM $vm -Confirm:$false
        
        # Wait for VM to be fully powered on
        $timeout = (Get-Date).AddMinutes(10)
        do {
            Start-Sleep -Seconds 10
            $vm = Get-VM -Name $vmEntry.VMName -ErrorAction SilentlyContinue
            if ($vm.PowerState -eq "PoweredOn") {
                break
            }
            Write-Host "[Thread $([System.Threading.Thread]::CurrentThread.ManagedThreadId)] Waiting for $($vmEntry.VMName) to power on..." -ForegroundColor Yellow
        } while ((Get-Date) -lt $timeout)
        
        if ($vm.PowerState -ne "PoweredOn") {
            Write-Warning "[Thread $([System.Threading.Thread]::CurrentThread.ManagedThreadId)] VM may not have started successfully"
        }
        
        # Step 6: Verify final configuration
        $vm = Get-VM -Name $vmEntry.VMName
        $vmView = Get-View -VIObject $vm
        
        $vmReport.NewCPUCount = $vmView.Config.Hardware.NumCPU
        $vmReport.NewCoresPerSocket = $vmView.Config.Hardware.NumCoresPerSocket
        $vmReport.NewCPUHotAddEnabled = $vmView.Config.CpuHotAddEnabled
        $vmReport.NewMemoryHotAddEnabled = $vmView.Config.MemoryHotAddEnabled
        $vmReport.FinalPowerState = $vm.PowerState
        $vmReport.Status = "Success"
        
        Write-Host "[Thread $([System.Threading.Thread]::CurrentThread.ManagedThreadId)] VM $($vmEntry.VMName) processed successfully" -ForegroundColor Green
        Write-Host "[Thread $([System.Threading.Thread]::CurrentThread.ManagedThreadId)] Final Config - CPU Count: $($vmReport.NewCPUCount), Cores per Socket: $($vmReport.NewCoresPerSocket)" -ForegroundColor Green
        
    } catch {
        $vmReport.Status = "Failed"
        $vmReport.ErrorMessage = $_.Exception.Message
        Write-Error "[Thread $([System.Threading.Thread]::CurrentThread.ManagedThreadId)] Failed to process VM $($vmEntry.VMName): $_"
    }
    
    return $vmReport
}

# Start parallel processing jobs
Write-Host "Starting parallel processing of $($VMList.Count) VMs..." -ForegroundColor Cyan
$jobs = @()
$maxConcurrentJobs = 5  # Adjust this number based on your environment's capacity

foreach ($vmEntry in $VMList) {
    # Wait if we've reached the maximum concurrent jobs
    while ((Get-Job -State Running).Count -ge $maxConcurrentJobs) {
        Start-Sleep -Seconds 2
        Write-Host "Waiting for available processing slot... ($((Get-Job -State Running).Count) jobs running)" -ForegroundColor Yellow
    }
    
    # Start background job for this VM
    $job = Start-Job -ScriptBlock $vmProcessingScript -ArgumentList $vmEntry, $connectedServers
    $jobs += $job
    Write-Host "Started processing job for VM: $($vmEntry.VMName) (Job ID: $($job.Id))" -ForegroundColor Gray
}

# Wait for all jobs to complete and collect results
Write-Host "`nWaiting for all VM processing jobs to complete..." -ForegroundColor Cyan
$report = @()
$completedJobs = 0

while ($jobs) {
    $finishedJobs = $jobs | Where-Object { $_.State -eq 'Completed' -or $_.State -eq 'Failed' }
    
    foreach ($job in $finishedJobs) {
        $completedJobs++
        Write-Host "Job $($job.Id) completed ($completedJobs/$($VMList.Count))" -ForegroundColor Green
        
        try {
            $result = Receive-Job -Job $job
            if ($result) {
                $report += $result
            }
        } catch {
            Write-Warning "Failed to retrieve results from job $($job.Id): $_"
        }
        
        Remove-Job -Job $job
        $jobs = $jobs | Where-Object { $_.Id -ne $job.Id }
    }
    
    if ($jobs) {
        Start-Sleep -Seconds 5
        $runningJobs = ($jobs | Where-Object { $_.State -eq 'Running' }).Count
        if ($runningJobs -gt 0) {
            Write-Host "Still processing... ($runningJobs jobs running, $completedJobs/$($VMList.Count) completed)" -ForegroundColor Yellow
        }
    }
}

# Generate and save report
Write-Host "`nGenerating report..." -ForegroundColor Cyan
$report | Export-Csv -Path $ReportPath -NoTypeInformation

Write-Host "`nProcess Summary:" -ForegroundColor Cyan
Write-Host "Total VMs processed: $($report.Count)" -ForegroundColor Yellow
Write-Host "Successful: $($report | Where-Object {$_.Status -eq 'Success'} | Measure-Object).Count" -ForegroundColor Green
Write-Host "Failed: $($report | Where-Object {$_.Status -eq 'Failed'} | Measure-Object).Count" -ForegroundColor Red
Write-Host "Report saved to: $ReportPath" -ForegroundColor Yellow

# Display summary table
Write-Host "`nDetailed Results:" -ForegroundColor Cyan
$report | Format-Table VMName, Status, NewCPUCount, NewCoresPerSocket, NewCPUHotAddEnabled, NewMemoryHotAddEnabled, FinalPowerState -AutoSize

# Disconnect from vCenter servers
foreach ($server in $connectedServers) {
    try {
        Disconnect-VIServer -Server $server -Confirm:$false
        Write-Host "Disconnected from $server" -ForegroundColor Green
    } catch {
        Write-Warning "Failed to disconnect from $server"
    }
}

Write-Host "`nScript completed!" -ForegroundColor Green
