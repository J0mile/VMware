# VM Configuration Update Script
# This script processes a CSV file to update VM CPU and memory settings

# Specify the CSV file path here
$CSVPath = "C:\path\to\your\vmlist.csv"

# Specify the report file path here
$ReportPath = "C:\Reports\VM_Configuration_Report_$(Get-Date -Format 'yyyyMMdd_HHmmss').csv"

Write-Host "Starting VM Configuration Update Script..." -ForegroundColor Green
Write-Host "Script started at: $(Get-Date)" -ForegroundColor Gray

# Set PowerCLI configuration to ignore certificate warnings
Write-Host "Configuring PowerCLI settings..." -ForegroundColor Yellow
try {
    Set-PowerCLIConfiguration -InvalidCertificateAction Ignore -Confirm:$false -Scope Session
    Write-Host "PowerCLI configuration set successfully" -ForegroundColor Green
} catch {
    Write-Warning "Failed to set PowerCLI configuration: $($_.Exception.Message)"
}

# vCenter connection parameters
$vCenterServers = @(
    "test.test.test",
    "test.test.test", 
    "test.test.test",
    "test.test.test",
    "test.test.test"
)

Write-Host "Starting VM Configuration Update Process" -ForegroundColor Cyan
Write-Host "CSV File: $CSVPath" -ForegroundColor Yellow
Write-Host "Report will be saved to: $ReportPath" -ForegroundColor Yellow

# Validate CSV file exists
Write-Host "Checking CSV file..." -ForegroundColor Yellow
Write-Host "Looking for CSV at: $CSVPath" -ForegroundColor Gray

if (!(Test-Path $CSVPath)) {
    Write-Error "CSV file not found at path: $CSVPath"
    Write-Host "Please check the file path and ensure the file exists." -ForegroundColor Red
    Read-Host "Press Enter to exit"
    exit 1
}
Write-Host "CSV file found successfully" -ForegroundColor Green

# Read and validate CSV file
Write-Host "Reading CSV file..." -ForegroundColor Yellow
try {
    $VMList = Import-Csv -Path $CSVPath
    Write-Host "Successfully imported CSV with $($VMList.Count) VMs" -ForegroundColor Green
    
    if ($VMList.Count -eq 0) {
        Write-Error "CSV file is empty or contains no data rows"
        Read-Host "Press Enter to exit"
        exit 1
    }
} catch {
    Write-Error "Failed to import CSV file: $($_.Exception.Message)"
    Read-Host "Press Enter to exit"
    exit 1
}

# Validate CSV headers
Write-Host "Validating CSV headers..." -ForegroundColor Yellow
$requiredHeaders = @("VMName", "PowerState", "CPUHotAddEnabled", "MemoryHotAddEnabled", "CPUCountBefore", "CPUCountAfter")
$csvHeaders = $VMList[0].PSObject.Properties.Name
Write-Host "Found headers: $($csvHeaders -join ', ')" -ForegroundColor Gray

$missingHeaders = $requiredHeaders | Where-Object { $_ -notin $csvHeaders }

if ($missingHeaders) {
    Write-Error "Missing required CSV headers: $($missingHeaders -join ', ')"
    Write-Host "Required headers: $($requiredHeaders -join ', ')" -ForegroundColor Yellow
    Read-Host "Press Enter to exit"
    exit 1
}
Write-Host "CSV headers validated successfully" -ForegroundColor Green

# Connect to vCenter servers
Write-Host "Preparing to connect to vCenter servers..." -ForegroundColor Yellow
$Credential = Get-Credential -Message "Enter vCenter credentials"

if (!$Credential) {
    Write-Error "No credentials provided. Exiting."
    Read-Host "Press Enter to exit"
    exit 1
}

$connectedServers = @()

Write-Host "Attempting to connect to vCenter servers..." -ForegroundColor Yellow
foreach ($vc in $vCenterServers) {
    Write-Host "Connecting to $vc..." -ForegroundColor Gray
    try {
        Connect-VIServer -Server $vc -Credential $Credential -ErrorAction Stop
        Write-Host "Connected to $vc" -ForegroundColor Green
        $connectedServers += $vc
    } catch {
        Write-Warning "Failed to connect to $vc : $($_.Exception.Message)"
    }
}

if ($connectedServers.Count -eq 0) {
    Write-Error "Failed to connect to any vCenter servers"
    Write-Host "Please check your credentials and server connectivity." -ForegroundColor Red
    Read-Host "Press Enter to exit"
    exit 1
}

Write-Host "Successfully connected to $($connectedServers.Count) vCenter server(s)" -ForegroundColor Green

# Initialize report array
$report = @()

# Function to wait for VM to be fully powered off
function Wait-VMPowerOff {
    param([string]$VMName, [int]$TimeoutMinutes = 10)
    
    $timeout = (Get-Date).AddMinutes($TimeoutMinutes)
    do {
        Start-Sleep -Seconds 10
        $vm = Get-VM -Name $VMName -ErrorAction SilentlyContinue
        if ($vm.PowerState -eq "PoweredOff") {
            return $true
        }
        Write-Host "Waiting for $VMName to power off..." -ForegroundColor Yellow
    } while ((Get-Date) -lt $timeout)
    
    return $false
}

# Function to wait for VM to be fully powered on
function Wait-VMPowerOn {
    param([string]$VMName, [int]$TimeoutMinutes = 10)
    
    $timeout = (Get-Date).AddMinutes($TimeoutMinutes)
    do {
        Start-Sleep -Seconds 10
        $vm = Get-VM -Name $VMName -ErrorAction SilentlyContinue
        if ($vm.PowerState -eq "PoweredOn") {
            return $true
        }
        Write-Host "Waiting for $VMName to power on..." -ForegroundColor Yellow
    } while ((Get-Date) -lt $timeout)
    
    return $false
}

# Display VMs that will be processed and ask for confirmation
Write-Host "`n" -ForegroundColor White
Write-Host "=" * 80 -ForegroundColor Yellow
Write-Host "VM CONFIGURATION CHANGE CONFIRMATION" -ForegroundColor Yellow
Write-Host "=" * 80 -ForegroundColor Yellow
Write-Host "`nThe following VMs from your CSV will be modified:" -ForegroundColor Cyan
Write-Host ""

# Display each VM with its planned changes
foreach ($vmEntry in $VMList) {
    Write-Host "VM Name: $($vmEntry.VMName)" -ForegroundColor White
    Write-Host "  Current Power State: $($vmEntry.PowerState)" -ForegroundColor Gray
    Write-Host "  CPU Count: $($vmEntry.CPUCountBefore) -> $($vmEntry.CPUCountAfter)" -ForegroundColor Yellow
    Write-Host "  Cores per Socket: Will be set to 1" -ForegroundColor Yellow
    Write-Host "  CPU Hot Add: $($vmEntry.CPUHotAddEnabled) -> TRUE" -ForegroundColor Yellow
    Write-Host "  Memory Hot Add: $($vmEntry.MemoryHotAddEnabled) -> TRUE" -ForegroundColor Yellow
    Write-Host "  Actions: Shutdown -> Reconfigure -> Power On" -ForegroundColor Red
    Write-Host ""
}

Write-Host "Total VMs to be modified: $($VMList.Count)" -ForegroundColor Cyan
Write-Host ""
Write-Host "WARNING: These VMs will be shut down and reconfigured!" -ForegroundColor Red -BackgroundColor Black
Write-Host ""
Write-Host "Do you want to proceed with these changes?" -ForegroundColor Yellow
Write-Host "Press ENTER to continue or CTRL+C to cancel..." -ForegroundColor White

# Wait for user confirmation
Read-Host

Write-Host "`nProceeding with VM configuration changes..." -ForegroundColor Green
Write-Host "=" * 80 -ForegroundColor Green

# Process VMs in batch mode (parallel processing)
Write-Host "`nProcessing VMs in batch mode..." -ForegroundColor Green
Write-Host "=" * 80 -ForegroundColor Green

# Create script block for parallel VM processing
$vmProcessingScript = {
    param($vmEntry, $vCenterServers, $Credential)
    
    # Function to update progress
    function Update-Progress {
        param($VMName, $Step, $Details = "")
        $timestamp = Get-Date -Format "HH:mm:ss"
        $threadId = [System.Threading.Thread]::CurrentThread.ManagedThreadId
        Write-Host "[$timestamp][Thread $threadId][$VMName] $Step $Details" -ForegroundColor Cyan
    }
    
    # Import PowerCLI in the background job
    Import-Module VMware.PowerCLI -ErrorAction SilentlyContinue
    Set-PowerCLIConfiguration -InvalidCertificateAction Ignore -Confirm:$false -Scope Session -ErrorAction SilentlyContinue
    
    $vmReport = [PSCustomObject]@{
        VMName = $vmEntry.VMName
        OriginalPowerState = $vmEntry.PowerState
        OriginalCPUHotAddEnabled = $vmEntry.CPUHotAddEnabled
        OriginalMemoryHotAddEnabled = $vmEntry.MemoryHotAddEnabled
        OriginalCPUCount = $vmEntry.CPUCountBefore
        TargetCPUCount = $vmEntry.CPUCountAfter
        NewCPUCount = ""
        NewCoresPerSocket = ""
        NewCPUHotAddEnabled = ""
        NewMemoryHotAddEnabled = ""
        FinalPowerState = ""
        Status = ""
        ErrorMessage = ""
        ProcessingThread = [System.Threading.Thread]::CurrentThread.ManagedThreadId
        StartTime = Get-Date
        EndTime = $null
        TotalProcessingTime = ""
    }
    
    try {
        Update-Progress -VMName $vmEntry.VMName -Step "STARTING" -Details "Beginning VM processing"
        
        # Connect to vCenter servers in this job (optimized - try to connect to fewer servers)
        Update-Progress -VMName $vmEntry.VMName -Step "CONNECTING" -Details "Connecting to vCenter servers"
        $jobConnectedServers = @()
        
        # Try to connect to servers one by one and stop when we find the VM
        foreach ($vc in $vCenterServers) {
            try {
                Connect-VIServer -Server $vc -Credential $Credential -ErrorAction Stop
                Update-Progress -VMName $vmEntry.VMName -Step "CONNECTED" -Details "Connected to $vc"
                $jobConnectedServers += $vc
                
                # Try to find VM on this server immediately
                $testVM = Get-VM -Name $vmEntry.VMName -Server $vc -ErrorAction SilentlyContinue
                if ($testVM) {
                    Update-Progress -VMName $vmEntry.VMName -Step "VM FOUND" -Details "Found on $vc, skipping other servers"
                    break  # Found VM, no need to connect to other servers
                }
            } catch {
                Update-Progress -VMName $vmEntry.VMName -Step "CONNECTION FAILED" -Details "Failed to connect to $vc : $($_.Exception.Message)"
            }
        }
        
        if ($jobConnectedServers.Count -eq 0) {
            throw "Failed to connect to any vCenter servers in background job"
        }
        
        # Find the specific VM from the CSV across connected vCenters
        Update-Progress -VMName $vmEntry.VMName -Step "SEARCHING" -Details "Locating VM across vCenter servers"
        $vm = $null
        foreach ($server in $jobConnectedServers) {
            $vm = Get-VM -Name $vmEntry.VMName -Server $server -ErrorAction SilentlyContinue
            if ($vm) {
                Update-Progress -VMName $vmEntry.VMName -Step "LOCATED" -Details "Found VM on server $server"
                break
            }
        }
        
        if (!$vm) {
            throw "VM '$($vmEntry.VMName)' from CSV not found on any connected vCenter server"
        }
        
        # Step 1: Shutdown VM if it's powered on
        if ($vm.PowerState -eq "PoweredOn") {
            Update-Progress -VMName $vmEntry.VMName -Step "SHUTDOWN INITIATED" -Details "Sending graceful shutdown command"
            Shutdown-VMGuest -VM $vm -Confirm:$false
            
            # Wait for VM to be fully powered off with better progress tracking
            Update-Progress -VMName $vmEntry.VMName -Step "SHUTDOWN WAITING" -Details "Waiting for graceful shutdown (timeout: 10 min)"
            $timeout = (Get-Date).AddMinutes(10)
            $shutdownStartTime = Get-Date
            $lastStatusTime = Get-Date
            
            do {
                Start-Sleep -Seconds 5  # Check more frequently
                $vm = Get-VM -Name $vmEntry.VMName -ErrorAction SilentlyContinue
                if ($vm.PowerState -eq "PoweredOff") {
                    $shutdownDuration = [math]::Round(((Get-Date) - $shutdownStartTime).TotalSeconds, 1)
                    Update-Progress -VMName $vmEntry.VMName -Step "SHUTDOWN COMPLETE" -Details "Graceful shutdown completed in $shutdownDuration seconds"
                    break
                }
                
                # Update progress every 30 seconds
                if (((Get-Date) - $lastStatusTime).TotalSeconds -ge 30) {
                    $elapsed = [math]::Round(((Get-Date) - $shutdownStartTime).TotalSeconds, 0)
                    Update-Progress -VMName $vmEntry.VMName -Step "SHUTDOWN WAITING" -Details "Still shutting down... ($elapsed seconds elapsed)"
                    $lastStatusTime = Get-Date
                }
            } while ((Get-Date) -lt $timeout)
            
            if ($vm.PowerState -ne "PoweredOff") {
                Update-Progress -VMName $vmEntry.VMName -Step "FORCE SHUTDOWN" -Details "Graceful shutdown timed out, forcing power off"
                Stop-VM -VM $vm -Confirm:$false
                Start-Sleep -Seconds 10  # Reduced wait time
                Update-Progress -VMName $vmEntry.VMName -Step "FORCE SHUTDOWN COMPLETE" -Details "Forced power off completed"
            }
        } else {
            Update-Progress -VMName $vmEntry.VMName -Step "ALREADY OFF" -Details "VM is already powered off, skipping shutdown"
        }
        
        # Refresh VM object
        $vm = Get-VM -Name $vmEntry.VMName
        
        # Step 2: Get current CPU configuration
        Update-Progress -VMName $vmEntry.VMName -Step "READING CONFIG" -Details "Getting current CPU configuration"
        $vmView = Get-View -VIObject $vm
        $currentCoresPerSocket = $vmView.Config.Hardware.NumCoresPerSocket
        $currentCPUCount = $vmView.Config.Hardware.NumCPU
        
        Update-Progress -VMName $vmEntry.VMName -Step "CONFIG READ" -Details "Current: $currentCPUCount CPUs, $currentCoresPerSocket cores/socket"
        
        # Step 3: Configure CPU settings (1 core per socket, update CPU count)
        $targetCPUCount = [int]$vmEntry.CPUCountAfter
        Update-Progress -VMName $vmEntry.VMName -Step "CONFIG CHANGE" -Details "Setting $targetCPUCount CPUs, 1 core/socket, enabling Hot Add"
        
        $vmConfigSpec = New-Object VMware.Vim.VirtualMachineConfigSpec
        $vmConfigSpec.NumCPUs = $targetCPUCount
        $vmConfigSpec.NumCoresPerSocket = 1
        
        # Step 4: Enable CPU and Memory Hot Add
        $vmConfigSpec.CpuHotAddEnabled = $true
        $vmConfigSpec.MemoryHotAddEnabled = $true
        
        # Apply configuration changes
        Update-Progress -VMName $vmEntry.VMName -Step "APPLYING CONFIG" -Details "Applying new CPU and Hot Add configuration to vCenter"
        $vmView.ReconfigVM($vmConfigSpec)
        Update-Progress -VMName $vmEntry.VMName -Step "CONFIG APPLIED" -Details "Configuration changes applied successfully"
        
        # Step 5: Power on the VM
        Update-Progress -VMName $vmEntry.VMName -Step "POWER ON INITIATED" -Details "Starting VM power on"
        Start-VM -VM $vm -Confirm:$false
        
        # Wait for VM to be fully powered on with better progress tracking
        Update-Progress -VMName $vmEntry.VMName -Step "POWER ON WAITING" -Details "Waiting for VM to start (timeout: 10 min)"
        $timeout = (Get-Date).AddMinutes(10)
        $powerOnStartTime = Get-Date
        $lastStatusTime = Get-Date
        
        do {
            Start-Sleep -Seconds 5  # Check more frequently
            $vm = Get-VM -Name $vmEntry.VMName -ErrorAction SilentlyContinue
            if ($vm.PowerState -eq "PoweredOn") {
                $powerOnDuration = [math]::Round(((Get-Date) - $powerOnStartTime).TotalSeconds, 1)
                Update-Progress -VMName $vmEntry.VMName -Step "POWER ON COMPLETE" -Details "VM started successfully in $powerOnDuration seconds"
                break
            }
            
            # Update progress every 30 seconds
            if (((Get-Date) - $lastStatusTime).TotalSeconds -ge 30) {
                $elapsed = [math]::Round(((Get-Date) - $powerOnStartTime).TotalSeconds, 0)
                Update-Progress -VMName $vmEntry.VMName -Step "POWER ON WAITING" -Details "Still starting... ($elapsed seconds elapsed)"
                $lastStatusTime = Get-Date
            }
        } while ((Get-Date) -lt $timeout)
        
        if ($vm.PowerState -ne "PoweredOn") {
            Update-Progress -VMName $vmEntry.VMName -Step "POWER ON TIMEOUT" -Details "VM did not start within timeout period"
        }
        
        # Step 6: Verify final configuration
        Update-Progress -VMName $vmEntry.VMName -Step "VERIFYING" -Details "Verifying final configuration"
        $vm = Get-VM -Name $vmEntry.VMName
        $vmView = Get-View -VIObject $vm
        
        $vmReport.NewCPUCount = $vmView.Config.Hardware.NumCPU
        $vmReport.NewCoresPerSocket = $vmView.Config.Hardware.NumCoresPerSocket
        $vmReport.NewCPUHotAddEnabled = $vmView.Config.CpuHotAddEnabled
        $vmReport.NewMemoryHotAddEnabled = $vmView.Config.MemoryHotAddEnabled
        $vmReport.FinalPowerState = $vm.PowerState
        $vmReport.Status = "Success"
        $vmReport.EndTime = Get-Date
        $vmReport.TotalProcessingTime = [math]::Round(($vmReport.EndTime - $vmReport.StartTime).TotalMinutes, 2)
        
        Update-Progress -VMName $vmEntry.VMName -Step "SUCCESS" -Details "Final: $($vmReport.NewCPUCount) CPUs, $($vmReport.NewCoresPerSocket) cores/socket, Hot Add enabled"
        Update-Progress -VMName $vmEntry.VMName -Step "COMPLETED" -Details "Total processing time: $($vmReport.TotalProcessingTime) minutes"
        
        # Disconnect from vCenter servers in this job
        foreach ($server in $jobConnectedServers) {
            try {
                Disconnect-VIServer -Server $server -Confirm:$false -ErrorAction SilentlyContinue
            } catch {
                # Ignore disconnect errors
            }
        }
        
    } catch {
        $vmReport.Status = "Failed"
        $vmReport.ErrorMessage = $_.Exception.Message
        $vmReport.EndTime = Get-Date
        if ($vmReport.StartTime) {
            $vmReport.TotalProcessingTime = [math]::Round(($vmReport.EndTime - $vmReport.StartTime).TotalMinutes, 2)
        }
        Update-Progress -VMName $vmEntry.VMName -Step "FAILED" -Details "Error: $($_.Exception.Message)"
    }
    
    return $vmReport
}

# Start parallel processing jobs
Write-Host "Starting parallel processing of $($VMList.Count) VMs..." -ForegroundColor Cyan
$jobs = @()
$maxConcurrentJobs = 5  # Adjust this number based on your environment's capacity

foreach ($vmEntry in $VMList) {
    # Wait if we've reached the maximum concurrent jobs
    while ((Get-Job -State Running).Count -ge $maxConcurrentJobs) {
        Start-Sleep -Seconds 2
        Write-Host "Waiting for available processing slot... ($((Get-Job -State Running).Count) jobs running)" -ForegroundColor Yellow
    }
    
    # Start background job for this VM
    $job = Start-Job -ScriptBlock $vmProcessingScript -ArgumentList $vmEntry, $vCenterServers, $Credential
    $jobs += $job
    Write-Host "Started processing job for VM: $($vmEntry.VMName) (Job ID: $($job.Id))" -ForegroundColor Gray
}

# Wait for all jobs to complete and collect results
Write-Host "`nWaiting for all VM processing jobs to complete..." -ForegroundColor Cyan
$report = @()
$completedJobs = 0

# Create a hashtable to track VM status
$vmStatus = @{}
foreach ($vmEntry in $VMList) {
    $vmStatus[$vmEntry.VMName] = "QUEUED"
}

while ($jobs) {
    $finishedJobs = $jobs | Where-Object { $_.State -eq 'Completed' -or $_.State -eq 'Failed' }
    
    foreach ($job in $finishedJobs) {
        $completedJobs++
        
        try {
            $result = Receive-Job -Job $job
            if ($result) {
                $report += $result
                $vmStatus[$result.VMName] = if ($result.Status -eq "Success") { "COMPLETED" } else { "FAILED" }
            }
        } catch {
            Write-Warning "Failed to retrieve results from job $($job.Id): $_"
        }
        
        Remove-Job -Job $job
        $jobs = $jobs | Where-Object { $_.Id -ne $job.Id }
    }
    
    if ($jobs) {
        Start-Sleep -Seconds 2  # Check more frequently
        $runningJobs = ($jobs | Where-Object { $_.State -eq 'Running' }).Count
        if ($runningJobs -gt 0) {
            # Show detailed status of all VMs
            Write-Host "`n=== VM Processing Status Update ===" -ForegroundColor Yellow
            Write-Host "Completed: $completedJobs/$($VMList.Count) | Running: $runningJobs | Queued: $(($VMList.Count) - $completedJobs - $runningJobs)" -ForegroundColor Cyan
            
            # Show status of each VM
            $statusLine = ""
            foreach ($vm in $VMList) {
                $status = $vmStatus[$vm.VMName]
                $color = switch ($status) {
                    "COMPLETED" { "Green" }
                    "FAILED" { "Red" }
                    "QUEUED" { "Gray" }
                    default { "Yellow" }
                }
                $statusLine += "$($vm.VMName):$status "
            }
            Write-Host $statusLine -ForegroundColor White
            Write-Host "Next update in 10 seconds...`n" -ForegroundColor Gray
            Start-Sleep -Seconds 8  # Total 10 seconds with the 2 above
        }
    }
}

# Generate and save report
Write-Host "`nGenerating report..." -ForegroundColor Cyan
$report | Export-Csv -Path $ReportPath -NoTypeInformation

Write-Host "`nProcess Summary:" -ForegroundColor Cyan
Write-Host "Total VMs processed: $($report.Count)" -ForegroundColor Yellow
Write-Host "Successful: $($report | Where-Object {$_.Status -eq 'Success'} | Measure-Object).Count" -ForegroundColor Green
Write-Host "Failed: $($report | Where-Object {$_.Status -eq 'Failed'} | Measure-Object).Count" -ForegroundColor Red
Write-Host "Report saved to: $ReportPath" -ForegroundColor Yellow

# Display summary table
Write-Host "`nDetailed Results:" -ForegroundColor Cyan
$report | Format-Table VMName, Status, NewCPUCount, NewCoresPerSocket, NewCPUHotAddEnabled, NewMemoryHotAddEnabled, FinalPowerState -AutoSize

# Disconnect from vCenter servers
foreach ($server in $connectedServers) {
    try {
        Disconnect-VIServer -Server $server -Confirm:$false
        Write-Host "Disconnected from $server" -ForegroundColor Green
    } catch {
        Write-Warning "Failed to disconnect from $server"
    }
}

Write-Host "`nScript completed!" -ForegroundColor Green
