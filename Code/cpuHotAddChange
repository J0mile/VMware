# VM Configuration Update Script - ROBUST PARALLEL VERSION (Full with Verbose Console)

# Specify the CSV file path here
$CSVPath = "C:\path\to\your\vmlist.csv"

# Specify the report file path here
$ReportPath = "C:\Reports\VM_Configuration_Report_$(Get-Date -Format 'yyyyMMdd_HHmmss').csv"

Write-Host "Starting VM Configuration Update Script (Parallel Mode)..." -ForegroundColor Green
Write-Host "Script started at: $(Get-Date)" -ForegroundColor Gray

Set-PowerCLIConfiguration -InvalidCertificateAction Ignore -Confirm:$false -Scope Session | Out-Null

# vCenter connection parameters
$vCenterServers = @(
    "test.test.test",
    "test.test.test", 
    "test.test.test",
    "test.test.test",
    "test.test.test"
)

Write-Host "CSV File: $CSVPath" -ForegroundColor Yellow
Write-Host "Report will be saved to: $ReportPath" -ForegroundColor Yellow

# Validate CSV file exists
if (!(Test-Path $CSVPath)) {
    Write-Error "CSV file not found at path: $CSVPath"
    Read-Host "Press Enter to exit"
    exit 1
}

# Read and validate CSV file
try {
    $VMList = Import-Csv -Path $CSVPath
    if ($VMList.Count -eq 0) {
        Write-Error "CSV file is empty or contains no data rows"
        Read-Host "Press Enter to exit"
        exit 1
    }
} catch {
    Write-Error "Failed to import CSV file: $($_.Exception.Message)"
    Read-Host "Press Enter to exit"
    exit 1
}

# Validate CSV headers
$requiredHeaders = @("VMName", "PowerState", "CPUHotAddEnabled", "MemoryHotAddEnabled", "CPUCountBefore", "CPUCountAfter")
$csvHeaders = $VMList[0].PSObject.Properties.Name
$missingHeaders = $requiredHeaders | Where-Object { $_ -notin $csvHeaders }

if ($missingHeaders) {
    Write-Error "Missing required CSV headers: $($missingHeaders -join ', ')"
    Read-Host "Press Enter to exit"
    exit 1
}

# Connect to vCenter
$Credential = Get-Credential -Message "Enter vCenter credentials"
if (!$Credential) {
    Write-Error "No credentials provided. Exiting."
    Read-Host "Press Enter to exit"
    exit 1
}

$connectedServers = @()
foreach ($vc in $vCenterServers) {
    try {
        Connect-VIServer -Server $vc -Credential $Credential -ErrorAction Stop | Out-Null
        $connectedServers += $vc
    } catch {
        Write-Warning "Failed to connect to $vc"
    }
}

if ($connectedServers.Count -eq 0) {
    Write-Error "Failed to connect to any vCenter servers"
    Read-Host "Press Enter to exit"
    exit 1
}

# Confirm details
Write-Host "`nVM CONFIGURATION PLAN:" -ForegroundColor Yellow
foreach ($vmEntry in $VMList) {
    Write-Host "  VM: $($vmEntry.VMName) | CPUs: $($vmEntry.CPUCountBefore) → $($vmEntry.CPUCountAfter)" -ForegroundColor Cyan
}
Read-Host "`nPress ENTER to begin..."

# Prepare parallel job script block (same as your version)
# You already provided this part — keeping as-is
# -----------------------------
# $vmProcessingScript = { ... } 
# -----------------------------

# Extract credentials for jobs
$Username = $Credential.UserName
$Password = $Credential.GetNetworkCredential().Password

# Parallel job handling
$jobs = @()
$maxJobs = 4
$jobCounter = 1

foreach ($vmEntry in $VMList) {
    while ((Get-Job -State Running).Count -ge $maxJobs) {
        Start-Sleep -Seconds 3
        $completedJobs = Get-Job | Where-Object { $_.State -eq 'Completed' }
        foreach ($completedJob in $completedJobs) {
            Write-Host "Job $($completedJob.Id) completed for processing..." -ForegroundColor Green
        }
    }

    $job = Start-Job -ScriptBlock $vmProcessingScript -ArgumentList $vmEntry, $vCenterServers, $Username, $Password, $jobCounter
    $jobs += [PSCustomObject]@{
        Job = $job
        VMName = $vmEntry.VMName 
        JobId = $jobCounter
        StartTime = Get-Date
    }

    Write-Host "Started Job $jobCounter for VM: $($vmEntry.VMName) (PowerShell Job ID: $($job.Id))" -ForegroundColor Cyan
    Write-Host "  CPU Before: $($vmEntry.CPUCountBefore)  => After: $($vmEntry.CPUCountAfter)" -ForegroundColor Gray
    Write-Host "  HotAdd CPU: $($vmEntry.CPUHotAddEnabled) | HotAdd Mem: $($vmEntry.MemoryHotAddEnabled)" -ForegroundColor Gray

    $jobCounter++
    Start-Sleep -Seconds 1
}

Write-Host "`nAll jobs started. Monitoring progress..." -ForegroundColor Green
Write-Host "Active PowerShell jobs: $((Get-Job -State Running).Count)" -ForegroundColor Yellow

# Enhanced job monitoring with more verbose output
$results = @()
$processedJobs = @()
$lastProgressUpdate = Get-Date

while ($jobs.Count -gt $processedJobs.Count) {
    $runningJobs = Get-Job -State Running
    $completedJobs = Get-Job | Where-Object { $_.State -ne 'Running' -and $_.Id -notin $processedJobs }

    foreach ($completedJob in $completedJobs) {
        $jobInfo = $jobs | Where-Object { $_.Job.Id -eq $completedJob.Id }
        if ($jobInfo) {
            Write-Host "`n>> Processing completed job for VM: $($jobInfo.VMName) (Job ID: $($jobInfo.JobId))" -ForegroundColor Magenta

            try {
                $jobResult = Receive-Job -Job $completedJob -ErrorAction Stop
                $vmResult = $jobResult | Where-Object { $_ -is [PSCustomObject] -and $_.PSObject.Properties.Name -contains "VMName" } | Select-Object -Last 1

                if ($vmResult) {
                    $results += $vmResult
                    $duration = [math]::Round(((Get-Date) - $jobInfo.StartTime).TotalMinutes, 2)

                    if ($vmResult.Status -eq "Success") {
                        Write-Host "✓ SUCCESS: $($vmResult.VMName) - $($vmResult.NewCPUCount) CPUs, Power: $($vmResult.FinalPowerState) ($duration min)" -ForegroundColor Green
                    } else {
                        Write-Host "✗ FAILED: $($vmResult.VMName) - $($vmResult.ErrorMessage)" -ForegroundColor Red
                    }

                    if ($vmResult.ProgressLog -and $vmResult.ProgressLog.Count -gt 0) {
                        Write-Host "--- Recent Logs for $($vmResult.VMName) ---" -ForegroundColor DarkCyan
                        $vmResult.ProgressLog | Select-Object -Last 5 | ForEach-Object {
                            Write-Host "    $_" -ForegroundColor Gray
                        }
                    }
                } else {
                    Write-Warning "Could not extract result for VM: $($jobInfo.VMName)"
                }
            } catch {
                Write-Warning "Error processing job $($completedJob.Id): $_"
            }

            Remove-Job -Job $completedJob -Force
            $processedJobs += $completedJob.Id
        }
    }

    if (((Get-Date) - $lastProgressUpdate).TotalSeconds -ge 15) {
        $completed = $processedJobs.Count
        $running = $runningJobs.Count
        $total = $jobs.Count

        Write-Host "`n--- PROGRESS UPDATE ---" -ForegroundColor Yellow
        Write-Host "Completed: $completed/$total | Running: $running | Remaining: $($total - $completed)" -ForegroundColor Cyan

        if ($running -gt 0) {
            Write-Host "Currently processing VMs:" -ForegroundColor Yellow
            $runningJobsInfo = $jobs | Where-Object { $_.Job.Id -in $runningJobs.Id }
            foreach ($runningJob in $runningJobsInfo) {
                $elapsed = [math]::Round(((Get-Date) - $runningJob.StartTime).TotalMinutes, 1)
                Write-Host "  • VM: $($runningJob.VMName) (Job $($runningJob.JobId) - $elapsed min elapsed)" -ForegroundColor Gray
            }
        }

        $lastProgressUpdate = Get-Date
    }

    Start-Sleep -Seconds 2
}

# Final report
if ($results.Count -gt 0) {
    $results | Export-Csv -Path $ReportPath -NoTypeInformation
    $success = ($results | Where-Object { $_.Status -eq 'Success' }).Count
    $failed = ($results | Where-Object { $_.Status -eq 'Failed' }).Count
    $avg = [math]::Round(($results | Measure-Object ProcessingTimeMinutes -Average).Average, 2)

    Write-Host "`n--- FINAL SUMMARY ---" -ForegroundColor Cyan
    Write-Host "  Total VMs: $($results.Count)" -ForegroundColor Yellow
    Write-Host "  Successful: $success" -ForegroundColor Green
    Write-Host "  Failed: $failed" -ForegroundColor Red
    Write-Host "  Avg Time: $avg min" -ForegroundColor Yellow
    Write-Host "  Report saved to: $ReportPath" -ForegroundColor Cyan
}

# Disconnect
foreach ($server in $connectedServers) {
    try {
        Disconnect-VIServer -Server $server -Confirm:$false | Out-Null
        Write-Host "Disconnected from $server" -ForegroundColor Gray
    } catch {
        Write-Warning "Could not disconnect from $server"
    }
}
