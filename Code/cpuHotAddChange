# VM Configuration Update Script - ROBUST PARALLEL VERSION
# This script processes a CSV file to update VM CPU and memory settings in parallel

# Specify the CSV file path here
$CSVPath = "C:\path\to\your\vmlist.csv"

# Specify the report file path here
$ReportPath = "C:\Reports\VM_Configuration_Report_$(Get-Date -Format 'yyyyMMdd_HHmmss').csv"

Write-Host "Starting VM Configuration Update Script (Parallel Mode)..." -ForegroundColor Green
Write-Host "Script started at: $(Get-Date)" -ForegroundColor Gray

# Set PowerCLI configuration to ignore certificate warnings
Write-Host "Configuring PowerCLI settings..." -ForegroundColor Yellow
try {
    Set-PowerCLIConfiguration -InvalidCertificateAction Ignore -Confirm:$false -Scope Session
    Write-Host "PowerCLI configuration set successfully" -ForegroundColor Green
} catch {
    Write-Warning "Failed to set PowerCLI configuration: $($_.Exception.Message)"
}

# vCenter connection parameters
$vCenterServers = @(
    "test.test.test",
    "test.test.test", 
    "test.test.test",
    "test.test.test",
    "test.test.test"
)

Write-Host "Starting VM Configuration Update Process" -ForegroundColor Cyan
Write-Host "CSV File: $CSVPath" -ForegroundColor Yellow
Write-Host "Report will be saved to: $ReportPath" -ForegroundColor Yellow

# Validate CSV file exists
Write-Host "Checking CSV file..." -ForegroundColor Yellow
if (!(Test-Path $CSVPath)) {
    Write-Error "CSV file not found at path: $CSVPath"
    Read-Host "Press Enter to exit"
    exit 1
}
Write-Host "CSV file found successfully" -ForegroundColor Green

# Read and validate CSV file
Write-Host "Reading CSV file..." -ForegroundColor Yellow
try {
    $VMList = Import-Csv -Path $CSVPath
    Write-Host "Successfully imported CSV with $($VMList.Count) VMs" -ForegroundColor Green
    
    if ($VMList.Count -eq 0) {
        Write-Error "CSV file is empty or contains no data rows"
        Read-Host "Press Enter to exit"
        exit 1
    }
} catch {
    Write-Error "Failed to import CSV file: $($_.Exception.Message)"
    Read-Host "Press Enter to exit"
    exit 1
}

# Validate CSV headers
Write-Host "Validating CSV headers..." -ForegroundColor Yellow
$requiredHeaders = @("VMName", "PowerState", "CPUHotAddEnabled", "MemoryHotAddEnabled", "CPUCountBefore", "CPUCountAfter")
$csvHeaders = $VMList[0].PSObject.Properties.Name
$missingHeaders = $requiredHeaders | Where-Object { $_ -notin $csvHeaders }

if ($missingHeaders) {
    Write-Error "Missing required CSV headers: $($missingHeaders -join ', ')"
    Write-Host "Required headers: $($requiredHeaders -join ', ')" -ForegroundColor Yellow
    Read-Host "Press Enter to exit"
    exit 1
}
Write-Host "CSV headers validated successfully" -ForegroundColor Green

# Connect to vCenter servers
Write-Host "Preparing to connect to vCenter servers..." -ForegroundColor Yellow
$Credential = Get-Credential -Message "Enter vCenter credentials"

if (!$Credential) {
    Write-Error "No credentials provided. Exiting."
    Read-Host "Press Enter to exit"
    exit 1
}

$connectedServers = @()

Write-Host "Attempting to connect to vCenter servers..." -ForegroundColor Yellow
foreach ($vc in $vCenterServers) {
    Write-Host "Connecting to $vc..." -ForegroundColor Gray
    try {
        Connect-VIServer -Server $vc -Credential $Credential -ErrorAction Stop
        Write-Host "Connected to $vc" -ForegroundColor Green
        $connectedServers += $vc
    } catch {
        Write-Warning "Failed to connect to $vc : $($_.Exception.Message)"
    }
}

if ($connectedServers.Count -eq 0) {
    Write-Error "Failed to connect to any vCenter servers"
    Read-Host "Press Enter to exit"
    exit 1
}

Write-Host "Successfully connected to $($connectedServers.Count) vCenter server(s)" -ForegroundColor Green

# Display confirmation
Write-Host "`n" + "=" * 80 -ForegroundColor Yellow
Write-Host "VM CONFIGURATION CHANGE CONFIRMATION" -ForegroundColor Yellow
Write-Host "=" * 80 -ForegroundColor Yellow

foreach ($vmEntry in $VMList) {
    Write-Host "VM: $($vmEntry.VMName) | CPU: $($vmEntry.CPUCountBefore) -> $($vmEntry.CPUCountAfter) | Hot Add: Enabled" -ForegroundColor Cyan
}

Write-Host "`nTotal VMs: $($VMList.Count) | Processing: PARALLEL" -ForegroundColor Yellow
Write-Host "WARNING: VMs will be shut down and reconfigured!" -ForegroundColor Red
Write-Host "`nPress ENTER to continue or CTRL+C to cancel..." -ForegroundColor White
Read-Host

# Create robust script block for parallel processing
$vmProcessingScript = {
    param($vmData, $vCenterList, $username, $password, $jobId)
    
    # Create a unique log identifier
    $logPrefix = "[$($vmData.VMName)][Job$jobId]"
    $progressLog = @()
    
    function Add-ProgressLog {
        param($Message)
        $timestamp = Get-Date -Format "HH:mm:ss.fff"
        $logEntry = "$timestamp $logPrefix $Message"
        $script:progressLog += $logEntry
        Write-Output $logEntry  # This goes to job output
    }
    
    try {
        Add-ProgressLog "STARTING - Initializing job environment"
        
        # Recreate credential securely
        $securePassword = ConvertTo-SecureString -String $password -AsPlainText -Force
        $jobCredential = New-Object System.Management.Automation.PSCredential($username, $securePassword)
        
        # Import PowerCLI with retry logic
        $moduleLoaded = $false
        $retryCount = 0
        while (-not $moduleLoaded -and $retryCount -lt 3) {
            try {
                if (Get-Module -ListAvailable -Name VMware.PowerCLI) {
                    Import-Module VMware.PowerCLI -Force -Global -ErrorAction Stop
                } elseif (Get-Module -ListAvailable -Name VMware.VimAutomation.Core) {
                    Import-Module VMware.VimAutomation.Core -Force -Global -ErrorAction Stop
                    Import-Module VMware.VimAutomation.Common -Force -Global -ErrorAction SilentlyContinue
                } else {
                    throw "PowerCLI modules not found"
                }
                
                Set-PowerCLIConfiguration -InvalidCertificateAction Ignore -Confirm:$false -Scope AllUsers -ErrorAction SilentlyContinue
                $moduleLoaded = $true
                Add-ProgressLog "INITIALIZED - PowerCLI loaded successfully"
            } catch {
                $retryCount++
                Add-ProgressLog "MODULE_RETRY - Attempt $retryCount failed: $($_.Exception.Message)"
                Start-Sleep -Seconds 2
            }
        }
        
        if (-not $moduleLoaded) {
            throw "Failed to load PowerCLI after 3 attempts"
        }
        
        # Initialize result object
        $result = [PSCustomObject]@{
            VMName = $vmData.VMName
            JobId = $jobId
            Status = "Processing"
            OriginalPowerState = $vmData.PowerState
            OriginalCPUCount = $vmData.CPUCountBefore
            TargetCPUCount = $vmData.CPUCountAfter
            NewCPUCount = ""
            NewCoresPerSocket = ""
            NewCPUHotAddEnabled = ""
            NewMemoryHotAddEnabled = ""
            FinalPowerState = ""
            ErrorMessage = ""
            StartTime = Get-Date
            EndTime = $null
            ProcessingTimeMinutes = 0
            ProgressLog = $progressLog
        }
        
        # Connect to vCenter servers
        Add-ProgressLog "CONNECTING - Attempting vCenter connections"
        $jobConnections = @()
        
        foreach ($vcServer in $vCenterList) {
            try {
                $connection = Connect-VIServer -Server $vcServer -Credential $jobCredential -ErrorAction Stop
                $jobConnections += $vcServer
                Add-ProgressLog "CONNECTED - Successfully connected to $vcServer"
                
                # Try to find VM immediately
                $testVM = Get-VM -Name $vmData.VMName -Server $vcServer -ErrorAction SilentlyContinue
                if ($testVM) {
                    Add-ProgressLog "VM_LOCATED - Found VM on $vcServer"
                    break
                }
            } catch {
                Add-ProgressLog "CONNECT_FAILED - $vcServer : $($_.Exception.Message)"
            }
        }
        
        if ($jobConnections.Count -eq 0) {
            throw "No vCenter connections established"
        }
        
        # Locate the VM
        Add-ProgressLog "SEARCHING - Looking for VM across connected servers"
        $targetVM = $null
        $vmServer = $null
        
        foreach ($server in $jobConnections) {
            $targetVM = Get-VM -Name $vmData.VMName -Server $server -ErrorAction SilentlyContinue
            if ($targetVM) {
                $vmServer = $server
                Add-ProgressLog "VM_FOUND - Located on $server"
                break
            }
        }
        
        if (-not $targetVM) {
            throw "VM '$($vmData.VMName)' not found on any connected vCenter"
        }
        
        # PHASE 1: Shutdown if needed
        if ($targetVM.PowerState -eq "PoweredOn") {
            Add-ProgressLog "SHUTDOWN_START - Initiating graceful shutdown"
            Shutdown-VMGuest -VM $targetVM -Confirm:$false
            
            $shutdownTimeout = (Get-Date).AddMinutes(8)
            $shutdownStart = Get-Date
            
            while ($targetVM.PowerState -ne "PoweredOff" -and (Get-Date) -lt $shutdownTimeout) {
                Start-Sleep -Seconds 10
                $targetVM = Get-VM -Name $vmData.VMName -Server $vmServer
                $elapsed = [math]::Round(((Get-Date) - $shutdownStart).TotalSeconds)
                
                if ($elapsed % 30 -eq 0) {  # Log every 30 seconds
                    Add-ProgressLog "SHUTDOWN_WAIT - Graceful shutdown in progress ($elapsed sec)"
                }
            }
            
            if ($targetVM.PowerState -ne "PoweredOff") {
                Add-ProgressLog "SHUTDOWN_FORCE - Graceful timeout, forcing power off"
                Stop-VM -VM $targetVM -Confirm:$false
                Start-Sleep -Seconds 5
                $targetVM = Get-VM -Name $vmData.VMName -Server $vmServer
            }
            
            Add-ProgressLog "SHUTDOWN_COMPLETE - VM is powered off"
        } else {
            Add-ProgressLog "SHUTDOWN_SKIP - VM already powered off"
        }
        
        # PHASE 2: Reconfigure VM
        Add-ProgressLog "CONFIG_START - Beginning VM reconfiguration"
        $vmView = Get-View -VIObject $targetVM
        $targetCPUs = [int]$vmData.CPUCountAfter
        
        $configSpec = New-Object VMware.Vim.VirtualMachineConfigSpec
        $configSpec.NumCPUs = $targetCPUs
        $configSpec.NumCoresPerSocket = 1
        $configSpec.CpuHotAddEnabled = $true
        $configSpec.MemoryHotAddEnabled = $true
        
        Add-ProgressLog "CONFIG_APPLY - Setting $targetCPUs CPUs, 1 core/socket, Hot Add enabled"
        $vmView.ReconfigVM($configSpec)
        Add-ProgressLog "CONFIG_COMPLETE - VM reconfiguration applied"
        
        # PHASE 3: Power on
        Add-ProgressLog "POWERON_START - Starting VM"
        Start-VM -VM $targetVM -Confirm:$false
        
        $powerOnTimeout = (Get-Date).AddMinutes(8)
        $powerOnStart = Get-Date
        
        while ($targetVM.PowerState -ne "PoweredOn" -and (Get-Date) -lt $powerOnTimeout) {
            Start-Sleep -Seconds 10
            $targetVM = Get-VM -Name $vmData.VMName -Server $vmServer
            $elapsed = [math]::Round(((Get-Date) - $powerOnStart).TotalSeconds)
            
            if ($elapsed % 30 -eq 0) {  # Log every 30 seconds
                Add-ProgressLog "POWERON_WAIT - VM starting up ($elapsed sec)"
            }
        }
        
        if ($targetVM.PowerState -eq "PoweredOn") {
            Add-ProgressLog "POWERON_COMPLETE - VM started successfully"
        } else {
            Add-ProgressLog "POWERON_TIMEOUT - VM did not start within timeout"
        }
        
        # PHASE 4: Verify and finalize
        Add-ProgressLog "VERIFY_START - Checking final configuration"
        $targetVM = Get-VM -Name $vmData.VMName -Server $vmServer
        $finalVmView = Get-View -VIObject $targetVM
        
        $result.NewCPUCount = $finalVmView.Config.Hardware.NumCPU
        $result.NewCoresPerSocket = $finalVmView.Config.Hardware.NumCoresPerSocket
        $result.NewCPUHotAddEnabled = $finalVmView.Config.CpuHotAddEnabled
        $result.NewMemoryHotAddEnabled = $finalVmView.Config.MemoryHotAddEnabled
        $result.FinalPowerState = $targetVM.PowerState
        $result.Status = "Success"
        $result.EndTime = Get-Date
        $result.ProcessingTimeMinutes = [math]::Round(($result.EndTime - $result.StartTime).TotalMinutes, 2)
        
        Add-ProgressLog "SUCCESS - Processing completed in $($result.ProcessingTimeMinutes) minutes"
        Add-ProgressLog "FINAL_CONFIG - CPUs: $($result.NewCPUCount), Cores/Socket: $($result.NewCoresPerSocket), Power: $($result.FinalPowerState)"
        
        # Cleanup connections
        foreach ($server in $jobConnections) {
            try {
                Disconnect-VIServer -Server $server -Confirm:$false -Force -ErrorAction SilentlyContinue
            } catch {
                # Ignore cleanup errors
            }
        }
        
    } catch {
        $result.Status = "Failed"
        $result.ErrorMessage = $_.Exception.Message
        $result.EndTime = Get-Date
        if ($result.StartTime) {
            $result.ProcessingTimeMinutes = [math]::Round(($result.EndTime - $result.StartTime).TotalMinutes, 2)
        }
        Add-ProgressLog "FAILED - $($_.Exception.Message)"
    }
    
    # Always include the progress log in the result
    $result.ProgressLog = $progressLog
    
    # Return the result object
    return $result
}

# Extract credentials for job parameters
$Username = $Credential.UserName
$Password = $Credential.GetNetworkCredential().Password

# Start parallel processing with improved job management
Write-Host "`nStarting parallel processing..." -ForegroundColor Green
Write-Host "Maximum concurrent jobs: 4" -ForegroundColor Yellow

$jobs = @()
$maxJobs = 4
$jobCounter = 1

# Start jobs in batches
foreach ($vmEntry in $VMList) {
    # Wait for available slot
    while ((Get-Job -State Running).Count -ge $maxJobs) {
        Start-Sleep -Seconds 3
        
        # Check for completed jobs and process them immediately
        $completedJobs = Get-Job | Where-Object { $_.State -eq 'Completed' }
        foreach ($completedJob in $completedJobs) {
            Write-Host "Job $($completedJob.Id) completed for processing..." -ForegroundColor Green
        }
    }
    
    # Start new job
    $job = Start-Job -ScriptBlock $vmProcessingScript -ArgumentList $vmEntry, $vCenterServers, $Username, $Password, $jobCounter
    $jobs += [PSCustomObject]@{
        Job = $job
        VMName = $vmEntry.VMName 
        JobId = $jobCounter
        StartTime = Get-Date
    }
    
    Write-Host "Started Job $jobCounter for VM: $($vmEntry.VMName) (PowerShell Job ID: $($job.Id))" -ForegroundColor Cyan
    $jobCounter++
    
    # Small delay to prevent overwhelming the system
    Start-Sleep -Seconds 1
}

Write-Host "`nAll jobs started. Monitoring progress..." -ForegroundColor Green
Write-Host "Active PowerShell jobs: $((Get-Job -State Running).Count)" -ForegroundColor Yellow

# Enhanced job monitoring with real-time progress
$results = @()
$processedJobs = @()
$lastProgressUpdate = Get-Date

while ($jobs.Count -gt $processedJobs.Count) {
    $runningJobs = Get-Job -State Running
    $completedJobs = Get-Job | Where-Object { $_.State -ne 'Running' -and $_.Id -notin $processedJobs }
    
    # Process completed jobs immediately
    foreach ($completedJob in $completedJobs) {
        $jobInfo = $jobs | Where-Object { $_.Job.Id -eq $completedJob.Id }
        if ($jobInfo) {
            Write-Host "`nProcessing completed job for VM: $($jobInfo.VMName)" -ForegroundColor Green
            
            try {
                $jobResult = Receive-Job -Job $completedJob -ErrorAction Stop
                
                # Find the result object in the output
                $vmResult = $jobResult | Where-Object { $_ -is [PSCustomObject] -and $_.PSObject.Properties.Name -contains "VMName" } | Select-Object -Last 1
                
                if ($vmResult) {
                    $results += $vmResult
                    $duration = [math]::Round(((Get-Date) - $jobInfo.StartTime).TotalMinutes, 2)
                    
                    if ($vmResult.Status -eq "Success") {
                        Write-Host "✓ SUCCESS: $($vmResult.VMName) - $($vmResult.NewCPUCount) CPUs, Power: $($vmResult.FinalPowerState) ($duration min)" -ForegroundColor Green
                    } else {
                        Write-Host "✗ FAILED: $($vmResult.VMName) - $($vmResult.ErrorMessage)" -ForegroundColor Red
                    }
                    
                    # Show last few progress entries
                    if ($vmResult.ProgressLog -and $vmResult.ProgressLog.Count -gt 0) {
                        $lastLogs = $vmResult.ProgressLog | Select-Object -Last 3
                        foreach ($log in $lastLogs) {
                            Write-Host "    $log" -ForegroundColor Gray
                        }
                    }
                } else {
                    Write-Warning "Could not extract result for VM: $($jobInfo.VMName)"
                }
            } catch {
                Write-Warning "Error processing job $($completedJob.Id): $_"
            }
            
            Remove-Job -Job $completedJob -Force
            $processedJobs += $completedJob.Id
        }
    }
    
    # Periodic status update
    if (((Get-Date) - $lastProgressUpdate).TotalSeconds -ge 15) {
        $completed = $processedJobs.Count
        $running = $runningJobs.Count
        $total = $jobs.Count
        
        Write-Host "`n--- PROGRESS UPDATE ---" -ForegroundColor Yellow
        Write-Host "Completed: $completed/$total | Running: $running | Remaining: $($total - $completed)" -ForegroundColor Cyan
        
        if ($running -gt 0) {
            Write-Host "Currently processing:" -ForegroundColor Yellow
            $runningJobsInfo = $jobs | Where-Object { $_.Job.Id -in $runningJobs.Id }
            foreach ($runningJob in $runningJobsInfo) {
                $elapsed = [math]::Round(((Get-Date) - $runningJob.StartTime).TotalMinutes, 1)
                Write-Host "  • $($runningJob.VMName) (Job $($runningJob.JobId) - $elapsed min)" -ForegroundColor Gray
            }
        }
        
        $lastProgressUpdate = Get-Date
    }
    
    Start-Sleep -Seconds 2
}

# Final processing and reporting
Write-Host "`n" + "=" * 80 -ForegroundColor Green
Write-Host "ALL JOBS COMPLETED - GENERATING FINAL REPORT" -ForegroundColor Green
Write-Host "=" * 80 -ForegroundColor Green

if ($results.Count -gt 0) {
    # Export detailed report
    $results | Export-Csv -Path $ReportPath -NoTypeInformation
    
    # Summary statistics
    $successful = ($results | Where-Object { $_.Status -eq "Success" }).Count
    $failed = ($results | Where-Object { $_.Status -eq "Failed" }).Count
    $avgTime = [math]::Round(($results | Measure-Object ProcessingTimeMinutes -Average).Average, 2)
    
    Write-Host "`nFINAL SUMMARY:" -ForegroundColor Cyan
    Write-Host "Total VMs: $($results.Count)" -ForegroundColor Yellow
    Write-Host "Successful: $successful" -ForegroundColor Green
    Write-Host "Failed: $failed" -ForegroundColor Red
    Write-Host "Average processing time: $avgTime minutes" -ForegroundColor Yellow
    Write-Host "Report saved: $ReportPath" -ForegroundColor Yellow
    
    # Detailed results table
    Write-Host "`nDETAILED RESULTS:" -ForegroundColor Cyan
    $results | Select-Object VMName, Status, NewCPUCount, NewCoresPerSocket, FinalPowerState, ProcessingTimeMinutes | 
        Format-Table -AutoSize
    
    # Show failures if any
    $failures = $results | Where-Object { $_.Status -eq "Failed" }
    if ($failures) {
        Write-Host "`nFAILURE DETAILS:" -ForegroundColor Red
        $failures | Select-Object VMName, ErrorMessage | Format-Table -AutoSize -Wrap
    }
    
} else {
    Write-Warning "No results collected! Check for job execution issues."
}

# Cleanup vCenter connections
Write-Host "`nCleaning up vCenter connections..." -ForegroundColor Yellow
foreach ($server in $connectedServers) {
    try {
        Disconnect-VIServer -Server $server -Confirm:$false
        Write-Host "Disconnected from $server" -ForegroundColor Green
    } catch {
        Write-Warning "Failed to disconnect from $server"
    }
}

Write-Host "`nScript completed at: $(Get-Date)" -ForegroundColor Green
Write-Host "Total script runtime: $([math]::Round(((Get-Date) - (Get-Date $MyInvocation.MyCommand.Definition).LastWriteTime).TotalMinutes, 2)) minutes" -ForegroundColor Cyan
