# VM Configuration Script - ROBUST JOB VERSION
# Addresses common PowerShell job issues

param(
    [string]$CSVPath = "C:\path\to\your\vmlist.csv",
    [string]$ReportPath = "C:\Reports\VM_Configuration_Report_$(Get-Date -Format 'yyyyMMdd_HHmmss').csv"
)

Write-Host "=== VM Configuration Script - Robust Job Version ===" -ForegroundColor Green
Write-Host "Started: $(Get-Date)" -ForegroundColor Gray

# Clean up any existing jobs first
Write-Host "Cleaning up any existing jobs..." -ForegroundColor Yellow
Get-Job | Remove-Job -Force -ErrorAction SilentlyContinue

# Test PowerShell jobs work at all
Write-Host "Testing PowerShell job functionality..." -ForegroundColor Yellow
$testJob = Start-Job -ScriptBlock { "Test successful" }
Start-Sleep 3

if ($testJob.State -eq "Completed") {
    $testResult = Receive-Job $testJob
    Write-Host "‚úì Job test passed: $testResult" -ForegroundColor Green
    Remove-Job $testJob
} else {
    Write-Host "‚úó Basic PowerShell jobs not working. State: $($testJob.State)" -ForegroundColor Red
    Write-Host "Switching to sequential processing..." -ForegroundColor Yellow
    Remove-Job $testJob -Force
    
    # Fall back to sequential processing
    & {
        # Include your sequential processing code here
        Write-Host "Sequential processing would run here..." -ForegroundColor Cyan
        return
    }
}

# Load and validate CSV
if (!(Test-Path $CSVPath)) {
    Write-Error "CSV not found: $CSVPath"
    exit 1
}

$VMList = Import-Csv $CSVPath
Write-Host "Loaded $($VMList.Count) VMs from CSV" -ForegroundColor Green

# Get credentials
$Credential = Get-Credential -Message "vCenter credentials"
if (!$Credential) {
    Write-Error "No credentials provided"
    exit 1
}

# vCenter servers
$vCenterServers = @(
    "test.test.test",
    "test.test.test", 
    "test.test.test",
    "test.test.test",
    "test.test.test"
)

# Test vCenter connectivity before starting jobs
Write-Host "Testing vCenter connectivity..." -ForegroundColor Yellow
$connectedServers = @()

foreach ($vc in $vCenterServers) {
    try {
        $connection = Connect-VIServer -Server $vc -Credential $Credential -ErrorAction Stop
        Write-Host "‚úì Connected to $vc" -ForegroundColor Green
        $connectedServers += $vc
    } catch {
        Write-Host "‚úó Failed to connect to $vc : $($_.Exception.Message)" -ForegroundColor Red
    }
}

if ($connectedServers.Count -eq 0) {
    Write-Error "Could not connect to any vCenter servers"
    exit 1
}

# Simplified, more reliable job script
$vmJobScript = {
    param($VMName, $CPUTarget, $vCenters, $Username, $Password)
    
    # Simple progress function
    function Write-Progress {
        param($Message)
        Write-Output "[$(Get-Date -Format 'HH:mm:ss')] [$VMName] $Message"
    }
    
    try {
        Write-Progress "STARTING job for $VMName"
        
        # Recreate credential
        $SecPass = ConvertTo-SecureString -String $Password -AsPlainText -Force  
        $Cred = New-Object System.Management.Automation.PSCredential($Username, $SecPass)
        Write-Progress "Credential recreated"
        
        # Try to import PowerCLI with more aggressive approach
        Write-Progress "Loading PowerCLI..."
        $modulePaths = @(
            "VMware.PowerCLI",
            "VMware.VimAutomation.Core", 
            "VMware.VimAutomation.Common"
        )
        
        $moduleLoaded = $false
        foreach ($moduleName in $modulePaths) {
            try {
                if (Get-Module -ListAvailable -Name $moduleName) {
                    Import-Module $moduleName -Force -Global
                    $moduleLoaded = $true
                    Write-Progress "Loaded module: $moduleName"
                    break
                }
            } catch {
                Write-Progress "Failed to load $moduleName : $($_.Exception.Message)"
            }
        }
        
        if (-not $moduleLoaded) {
            throw "Could not load any PowerCLI modules"
        }
        
        # Set PowerCLI config
        Set-PowerCLIConfiguration -InvalidCertificateAction Ignore -Confirm:$false -Scope Session -ErrorAction SilentlyContinue
        Write-Progress "PowerCLI configured"
        
        # Connect to vCenter
        $connected = $false
        foreach ($vc in $vCenters) {
            try {
                Connect-VIServer -Server $vc -Credential $Cred -ErrorAction Stop | Out-Null
                Write-Progress "Connected to $vc"
                $connected = $true
                
                # Try to find VM immediately
                $vm = Get-VM -Name $VMName -Server $vc -ErrorAction SilentlyContinue
                if ($vm) {
                    Write-Progress "Found VM on $vc"
                    break
                }
            } catch {
                Write-Progress "Connection to $vc failed: $($_.Exception.Message)"
            }
        }
        
        if (-not $connected) {
            throw "Could not connect to any vCenter"
        }
        
        # Find VM
        $vm = Get-VM -Name $VMName -ErrorAction SilentlyContinue
        if (-not $vm) {
            throw "VM $VMName not found"
        }
        Write-Progress "VM located successfully"
        
        # Process VM
        if ($vm.PowerState -eq "PoweredOn") {
            Write-Progress "Shutting down VM..."
            Shutdown-VMGuest -VM $vm -Confirm:$false
            
            # Wait for shutdown (simplified)
            $timeout = 300 # 5 minutes
            $elapsed = 0
            while ($vm.PowerState -ne "PoweredOff" -and $elapsed -lt $timeout) {
                Start-Sleep 10
                $elapsed += 10
                $vm = Get-VM -Name $VMName
                if ($elapsed % 60 -eq 0) {
                    Write-Progress "Still shutting down... ($elapsed seconds)"
                }
            }
            
            if ($vm.PowerState -ne "PoweredOff") {
                Write-Progress "Forcing power off..."
                Stop-VM -VM $vm -Confirm:$false
                Start-Sleep 5
            }
            Write-Progress "VM is now powered off"
        }
        
        # Configure VM
        Write-Progress "Configuring VM..."
        $vmView = Get-View -VIObject $vm
        $spec = New-Object VMware.Vim.VirtualMachineConfigSpec
        $spec.NumCPUs = [int]$CPUTarget
        $spec.NumCoresPerSocket = 1
        $spec.CpuHotAddEnabled = $true
        $spec.MemoryHotAddEnabled = $true
        
        $vmView.ReconfigVM($spec)
        Write-Progress "VM reconfigured"
        
        # Power on
        Write-Progress "Powering on VM..."
        Start-VM -VM $vm -Confirm:$false
        
        # Wait for power on (simplified)
        $timeout = 300
        $elapsed = 0
        while ($vm.PowerState -ne "PoweredOn" -and $elapsed -lt $timeout) {
            Start-Sleep 10
            $elapsed += 10
            $vm = Get-VM -Name $VMName
            if ($elapsed % 60 -eq 0) {
                Write-Progress "Still powering on... ($elapsed seconds)"
            }
        }
        
        # Final verification
        $vm = Get-VM -Name $VMName
        $vmView = Get-View -VIObject $vm
        
        $result = [PSCustomObject]@{
            VMName = $VMName
            Status = "Success"
            NewCPUCount = $vmView.Config.Hardware.NumCPU
            NewCoresPerSocket = $vmView.Config.Hardware.NumCoresPerSocket
            CPUHotAddEnabled = $vmView.Config.CpuHotAddEnabled
            MemoryHotAddEnabled = $vmView.Config.MemoryHotAddEnabled
            PowerState = $vm.PowerState
        }
        
        Write-Progress "SUCCESS - $($result.NewCPUCount) CPUs, Hot Add enabled, Power: $($result.PowerState)"
        
        # Clean disconnect
        Get-VIServer | Disconnect-VIServer -Confirm:$false -Force -ErrorAction SilentlyContinue
        
        return $result
        
    } catch {
        Write-Progress "FAILED: $($_.Exception.Message)"
        return [PSCustomObject]@{
            VMName = $VMName
            Status = "Failed"
            ErrorMessage = $_.Exception.Message
        }
    }
}

# Extract credential components
$Username = $Credential.UserName
$Password = $Credential.GetNetworkCredential().Password

# Start jobs with DETAILED real-time monitoring
Write-Host "`nStarting VM processing jobs with enhanced monitoring..." -ForegroundColor Cyan
$jobs = @()
$results = @()
$jobTracker = @{}  # Track job start times and VM names

foreach ($vmEntry in $VMList) {
    # Process completed jobs and show detailed progress
    $completedJobs = Get-Job -State Completed
    foreach ($completedJob in $completedJobs) {
        $vmName = $jobTracker[$completedJob.Id]
        Write-Host "`nüîÑ PROCESSING COMPLETED JOB for $vmName" -ForegroundColor Green
        try {
            $jobOutput = Receive-Job -Job $completedJob
            
            # Show ALL progress messages from the job
            $progressMessages = $jobOutput | Where-Object { $_ -is [string] }
            if ($progressMessages) {
                Write-Host "   üìã Job Progress Log:" -ForegroundColor Cyan
                $progressMessages | ForEach-Object {
                    Write-Host "     $_" -ForegroundColor Gray
                }
            }
            
            # Extract result
            $result = $jobOutput | Where-Object { $_ -is [PSCustomObject] } | Select-Object -Last 1
            if ($result) {
                $results += $result
                if ($result.Status -eq "Success") {
                    Write-Host "   ‚úÖ SUCCESS: $($result.VMName) - $($result.NewCPUCount) CPUs, Power: $($result.PowerState)" -ForegroundColor Green
                } else {
                    Write-Host "   ‚ùå FAILED: $($result.VMName) - $($result.ErrorMessage)" -ForegroundColor Red
                }
            }
        } catch {
            Write-Host "   ‚ö†Ô∏è  Error processing job: $_" -ForegroundColor Red
        }
        Remove-Job -Job $completedJob
        $jobTracker.Remove($completedJob.Id)
    }
    
    # Wait for job slot with detailed status
    while ((Get-Job -State Running).Count -ge 3) {
        $runningJobs = Get-Job -State Running
        Write-Host "`n‚è≥ WAITING FOR JOB SLOT..." -ForegroundColor Yellow
        Write-Host "   Currently running jobs:" -ForegroundColor Yellow
        
        foreach ($runningJob in $runningJobs) {
            $vmName = $jobTracker[$runningJob.Id]
            $runtime = if ($runningJob.PSBeginTime) { 
                [math]::Round(((Get-Date) - $runningJob.PSBeginTime).TotalMinutes, 1) 
            } else { "Unknown" }
            
            Write-Host "     ‚Ä¢ Job $($runningJob.Id): $vmName (running $runtime min)" -ForegroundColor Gray
            
            # Try to peek at recent output
            if ($runningJob.HasMoreData) {
                try {
                    $recentOutput = Receive-Job -Job $runningJob -Keep | Select-Object -Last 1
                    if ($recentOutput) {
                        Write-Host "       Latest: $recentOutput" -ForegroundColor DarkGray
                    }
                } catch {
                    Write-Host "       (No recent output)" -ForegroundColor DarkGray
                }
            } else {
                Write-Host "       (No output yet)" -ForegroundColor DarkGray
            }
        }
        
        # Check for any completed jobs during wait
        $newCompleted = Get-Job -State Completed
        if ($newCompleted) {
            Write-Host "   üéâ Jobs completed while waiting!" -ForegroundColor Green
            break
        }
        
        Start-Sleep 10
    }
    
    # Start new job with detailed info
    $targetCPUs = $vmEntry.CPUCountAfter
    $job = Start-Job -ScriptBlock $vmJobScript -ArgumentList $vmEntry.VMName, $targetCPUs, $connectedServers, $Username, $Password
    $jobs += $job
    $jobTracker[$job.Id] = $vmEntry.VMName
    
    Write-Host "`nüöÄ STARTED NEW JOB" -ForegroundColor Cyan
    Write-Host "   Job ID: $($job.Id)" -ForegroundColor White
    Write-Host "   VM Name: $($vmEntry.VMName)" -ForegroundColor White  
    Write-Host "   Target CPUs: $($vmEntry.CPUCountBefore) ‚Üí $targetCPUs" -ForegroundColor White
    Write-Host "   Started: $(Get-Date -Format 'HH:mm:ss')" -ForegroundColor White
    Write-Host "   Total active jobs: $((Get-Job -State Running).Count)" -ForegroundColor Yellow
    
    Start-Sleep 3  # Give job time to initialize
    
    # Check if job started successfully
    $job = Get-Job -Id $job.Id
    if ($job.State -eq "Failed") {
        Write-Host "   ‚ùå JOB FAILED TO START!" -ForegroundColor Red
        try {
            $failureOutput = Receive-Job -Job $job
            Write-Host "   Error details: $failureOutput" -ForegroundColor Red
        } catch {
            Write-Host "   Could not get failure details" -ForegroundColor Red
        }
        Remove-Job -Job $job
        $jobTracker.Remove($job.Id)
    } elseif ($job.State -eq "Running") {
        Write-Host "   ‚úÖ Job running successfully" -ForegroundColor Green
        
        # Try to get initial output
        Start-Sleep 2
        if ($job.HasMoreData) {
            try {
                $initialOutput = Receive-Job -Job $job -Keep | Select-Object -Last 2
                if ($initialOutput) {
                    Write-Host "   Initial progress:" -ForegroundColor Cyan
                    $initialOutput | ForEach-Object { Write-Host "     $_" -ForegroundColor Gray }
                }
            } catch {
                Write-Host "   (Waiting for initial output...)" -ForegroundColor Gray
            }
        }
    }
}

# Monitor remaining jobs with DETAILED status updates
Write-Host "`nüîç MONITORING REMAINING JOBS..." -ForegroundColor Yellow
$monitorStartTime = Get-Date

while (Get-Job -State Running) {
    $runningJobs = Get-Job -State Running
    $completedCount = $results.Count
    $totalJobs = $VMList.Count
    
    Write-Host "`n" + "="*60 -ForegroundColor Cyan
    Write-Host "üìä PROGRESS UPDATE - $(Get-Date -Format 'HH:mm:ss')" -ForegroundColor Cyan
    Write-Host "   ‚úÖ Completed: $completedCount/$totalJobs" -ForegroundColor Green
    Write-Host "   üîÑ Running: $($runningJobs.Count)" -ForegroundColor Yellow
    Write-Host "   ‚è±Ô∏è  Total runtime: $([math]::Round(((Get-Date) - $monitorStartTime).TotalMinutes, 1)) minutes" -ForegroundColor Gray
    Write-Host "="*60 -ForegroundColor Cyan
    
    # Show detailed status of each running job
    if ($runningJobs.Count -gt 0) {
        Write-Host "`nüîÑ ACTIVE JOBS DETAIL:" -ForegroundColor Yellow
        foreach ($runningJob in $runningJobs) {
            $vmName = $jobTracker[$runningJob.Id]
            $runtime = if ($runningJob.PSBeginTime) { 
                [math]::Round(((Get-Date) - $runningJob.PSBeginTime).TotalMinutes, 1) 
            } else { "Unknown" }
            
            Write-Host "   üñ•Ô∏è  VM: $vmName (Job $($runningJob.Id))" -ForegroundColor White
            Write-Host "     ‚è±Ô∏è  Runtime: $runtime minutes" -ForegroundColor Gray
            Write-Host "     üìä State: $($runningJob.State)" -ForegroundColor Gray
            Write-Host "     üìù Has Output: $($runningJob.HasMoreData)" -ForegroundColor Gray
            
            # Get the latest progress from the job
            if ($runningJob.HasMoreData) {
                try {
                    $latestOutput = Receive-Job -Job $runningJob -Keep | Select-Object -Last 2
                    if ($latestOutput) {
                        Write-Host "     üí¨ Latest Activity:" -ForegroundColor Cyan
                        $latestOutput | ForEach-Object { 
                            Write-Host "       $_" -ForegroundColor DarkCyan 
                        }
                    }
                } catch {
                    Write-Host "     üí¨ (Checking for activity...)" -ForegroundColor DarkGray
                }
            } else {
                Write-Host "     üí¨ (No output yet - job may be initializing)" -ForegroundColor DarkGray
            }
            
            # Warn about stuck jobs
            if ($runtime -gt 15 -and -not $runningJob.HasMoreData) {
                Write-Host "     ‚ö†Ô∏è  WARNING: Job may be stuck (no output for $runtime minutes)" -ForegroundColor Red
            }
            
            Write-Host ""
        }
    }
    
    # Process any newly completed jobs with full detail
    $completedJobs = Get-Job -State Completed
    foreach ($completedJob in $completedJobs) {
        $vmName = $jobTracker[$completedJob.Id]
        Write-Host "`nüéâ JOB COMPLETED: $vmName" -ForegroundColor Green
        Write-Host "   Job ID: $($completedJob.Id)" -ForegroundColor White
        Write-Host "   Processing results..." -ForegroundColor Yellow
        
        try {
            $jobOutput = Receive-Job -Job $completedJob
            
            # Show complete progress log
            $progressMessages = $jobOutput | Where-Object { $_ -is [string] }
            if ($progressMessages) {
                Write-Host "   üìã Complete Progress Log:" -ForegroundColor Cyan
                $progressMessages | ForEach-Object {
                    Write-Host "     $_" -ForegroundColor Gray
                }
            }
            
            # Extract and show result
            $result = $jobOutput | Where-Object { $_ -is [PSCustomObject] } | Select-Object -Last 1
            if ($result) {
                $results += $result
                Write-Host "`n   üìä FINAL RESULT:" -ForegroundColor White
                if ($result.Status -eq "Success") {
                    Write-Host "   ‚úÖ STATUS: SUCCESS" -ForegroundColor Green
                    Write-Host "   üñ•Ô∏è  VM: $($result.VMName)" -ForegroundColor White
                    Write-Host "   üîß CPUs: $($result.NewCPUCount)" -ForegroundColor White
                    Write-Host "   üî• CPU Hot Add: $($result.CPUHotAddEnabled)" -ForegroundColor White
                    Write-Host "   üî• Memory Hot Add: $($result.MemoryHotAddEnabled)" -ForegroundColor White
                    Write-Host "   ‚ö° Power State: $($result.PowerState)" -ForegroundColor White
                } else {
                    Write-Host "   ‚ùå STATUS: FAILED" -ForegroundColor Red
                    Write-Host "   üñ•Ô∏è  VM: $($result.VMName)" -ForegroundColor White
                    Write-Host "   ‚ùó Error: $($result.ErrorMessage)" -ForegroundColor Red
                }
            } else {
                Write-Host "   ‚ö†Ô∏è  Could not extract result object" -ForegroundColor Yellow
            }
        } catch {
            Write-Host "   ‚ùå Error processing job results: $_" -ForegroundColor Red
        }
        
        Remove-Job -Job $completedJob
        $jobTracker.Remove($completedJob.Id)
        Write-Host "   üóëÔ∏è  Job cleaned up" -ForegroundColor Gray
    }
    
    Write-Host "`n‚è≥ Next update in 15 seconds..." -ForegroundColor DarkGray
    Start-Sleep 15
}

# Final cleanup and reporting
Get-Job | Remove-Job -Force
foreach ($server in $connectedServers) {
    Disconnect-VIServer -Server $server -Confirm:$false -Force -ErrorAction SilentlyContinue
}

# Generate report
if ($results.Count -gt 0) {
    $results | Export-Csv -Path $ReportPath -NoTypeInformation
    
    Write-Host "`n=== FINAL RESULTS ===" -ForegroundColor Green
    Write-Host "Total processed: $($results.Count)" -ForegroundColor Yellow
    Write-Host "Successful: $(($results | Where-Object Status -eq 'Success').Count)" -ForegroundColor Green
    Write-Host "Failed: $(($results | Where-Object Status -eq 'Failed').Count)" -ForegroundColor Red
    
    $results | Format-Table VMName, Status, NewCPUCount, PowerState -AutoSize
} else {
    Write-Warning "No results collected!"
}

Write-Host "`nScript completed: $(Get-Date)" -ForegroundColor Green
