# VM Configuration Update Script - FIXED VERSION
# This script processes a CSV file to update VM CPU and memory settings

# Specify the CSV file path here
$CSVPath = "C:\path\to\your\vmlist.csv"

# Specify the report file path here
$ReportPath = "C:\Reports\VM_Configuration_Report_$(Get-Date -Format 'yyyyMMdd_HHmmss').csv"

Write-Host "Starting VM Configuration Update Script..." -ForegroundColor Green
Write-Host "Script started at: $(Get-Date)" -ForegroundColor Gray

# Set PowerCLI configuration to ignore certificate warnings
Write-Host "Configuring PowerCLI settings..." -ForegroundColor Yellow
try {
    Set-PowerCLIConfiguration -InvalidCertificateAction Ignore -Confirm:$false -Scope Session
    Write-Host "PowerCLI configuration set successfully" -ForegroundColor Green
} catch {
    Write-Warning "Failed to set PowerCLI configuration: $($_.Exception.Message)"
}

# vCenter connection parameters
$vCenterServers = @(
    "test.test.test",
    "test.test.test", 
    "test.test.test",
    "test.test.test",
    "test.test.test"
)

Write-Host "Starting VM Configuration Update Process" -ForegroundColor Cyan
Write-Host "CSV File: $CSVPath" -ForegroundColor Yellow
Write-Host "Report will be saved to: $ReportPath" -ForegroundColor Yellow

# Validate CSV file exists
Write-Host "Checking CSV file..." -ForegroundColor Yellow
Write-Host "Looking for CSV at: $CSVPath" -ForegroundColor Gray

if (!(Test-Path $CSVPath)) {
    Write-Error "CSV file not found at path: $CSVPath"
    Write-Host "Please check the file path and ensure the file exists." -ForegroundColor Red
    Read-Host "Press Enter to exit"
    exit 1
}
Write-Host "CSV file found successfully" -ForegroundColor Green

# Read and validate CSV file
Write-Host "Reading CSV file..." -ForegroundColor Yellow
try {
    $VMList = Import-Csv -Path $CSVPath
    Write-Host "Successfully imported CSV with $($VMList.Count) VMs" -ForegroundColor Green
    
    if ($VMList.Count -eq 0) {
        Write-Error "CSV file is empty or contains no data rows"
        Read-Host "Press Enter to exit"
        exit 1
    }
} catch {
    Write-Error "Failed to import CSV file: $($_.Exception.Message)"
    Read-Host "Press Enter to exit"
    exit 1
}

# Validate CSV headers
Write-Host "Validating CSV headers..." -ForegroundColor Yellow
$requiredHeaders = @("VMName", "PowerState", "CPUHotAddEnabled", "MemoryHotAddEnabled", "CPUCountBefore", "CPUCountAfter")
$csvHeaders = $VMList[0].PSObject.Properties.Name
Write-Host "Found headers: $($csvHeaders -join ', ')" -ForegroundColor Gray

$missingHeaders = $requiredHeaders | Where-Object { $_ -notin $csvHeaders }

if ($missingHeaders) {
    Write-Error "Missing required CSV headers: $($missingHeaders -join ', ')"
    Write-Host "Required headers: $($requiredHeaders -join ', ')" -ForegroundColor Yellow
    Read-Host "Press Enter to exit"
    exit 1
}
Write-Host "CSV headers validated successfully" -ForegroundColor Green

# Connect to vCenter servers
Write-Host "Preparing to connect to vCenter servers..." -ForegroundColor Yellow
$Credential = Get-Credential -Message "Enter vCenter credentials"

if (!$Credential) {
    Write-Error "No credentials provided. Exiting."
    Read-Host "Press Enter to exit"
    exit 1
}

$connectedServers = @()

Write-Host "Attempting to connect to vCenter servers..." -ForegroundColor Yellow
foreach ($vc in $vCenterServers) {
    Write-Host "Connecting to $vc..." -ForegroundColor Gray
    try {
        Connect-VIServer -Server $vc -Credential $Credential -ErrorAction Stop
        Write-Host "Connected to $vc" -ForegroundColor Green
        $connectedServers += $vc
    } catch {
        Write-Warning "Failed to connect to $vc : $($_.Exception.Message)"
    }
}

if ($connectedServers.Count -eq 0) {
    Write-Error "Failed to connect to any vCenter servers"
    Write-Host "Please check your credentials and server connectivity." -ForegroundColor Red
    Read-Host "Press Enter to exit"
    exit 1
}

Write-Host "Successfully connected to $($connectedServers.Count) vCenter server(s)" -ForegroundColor Green

# Initialize report array
$report = @()

# Display VMs that will be processed and ask for confirmation
Write-Host "`n" -ForegroundColor White
Write-Host "=" * 80 -ForegroundColor Yellow
Write-Host "VM CONFIGURATION CHANGE CONFIRMATION" -ForegroundColor Yellow
Write-Host "=" * 80 -ForegroundColor Yellow
Write-Host "`nThe following VMs from your CSV will be modified:" -ForegroundColor Cyan
Write-Host ""

# Display each VM with its planned changes
foreach ($vmEntry in $VMList) {
    Write-Host "VM Name: $($vmEntry.VMName)" -ForegroundColor White
    Write-Host "  Current Power State: $($vmEntry.PowerState)" -ForegroundColor Gray
    Write-Host "  CPU Count: $($vmEntry.CPUCountBefore) -> $($vmEntry.CPUCountAfter)" -ForegroundColor Yellow
    Write-Host "  Cores per Socket: Will be set to 1" -ForegroundColor Yellow
    Write-Host "  CPU Hot Add: $($vmEntry.CPUHotAddEnabled) -> TRUE" -ForegroundColor Yellow
    Write-Host "  Memory Hot Add: $($vmEntry.MemoryHotAddEnabled) -> TRUE" -ForegroundColor Yellow
    Write-Host "  Actions: Shutdown -> Reconfigure -> Power On" -ForegroundColor Red
    Write-Host ""
}

Write-Host "Total VMs to be modified: $($VMList.Count)" -ForegroundColor Cyan
Write-Host ""
Write-Host "WARNING: These VMs will be shut down and reconfigured!" -ForegroundColor Red -BackgroundColor Black
Write-Host ""
Write-Host "Do you want to proceed with these changes?" -ForegroundColor Yellow
Write-Host "Press ENTER to continue or CTRL+C to cancel..." -ForegroundColor White

# Wait for user confirmation
Read-Host

Write-Host "`nProceeding with VM configuration changes..." -ForegroundColor Green
Write-Host "=" * 80 -ForegroundColor Green

# Process VMs in batch mode (parallel processing)
Write-Host "`nProcessing VMs in batch mode..." -ForegroundColor Green
Write-Host "=" * 80 -ForegroundColor Green

# Create script block for parallel VM processing - FIXED VERSION
$vmProcessingScript = {
    param($vmEntry, $vCenterServers, $Username, $Password)
    
    # Function to update progress with error handling
    function Update-Progress {
        param($VMName, $Step, $Details = "")
        try {
            $timestamp = Get-Date -Format "HH:mm:ss"
            $threadId = [System.Threading.Thread]::CurrentThread.ManagedThreadId
            Write-Output "[$timestamp][Thread $threadId][$VMName] $Step $Details"
        } catch {
            Write-Output "[$VMName] $Step $Details"
        }
    }
    
    # Recreate credential object from username/password
    try {
        $SecurePassword = ConvertTo-SecureString -String $Password -AsPlainText -Force
        $Credential = New-Object System.Management.Automation.PSCredential($Username, $SecurePassword)
    } catch {
        return [PSCustomObject]@{
            VMName = $vmEntry.VMName
            Status = "Failed"
            ErrorMessage = "Failed to recreate credentials: $($_.Exception.Message)"
            StartTime = Get-Date
            EndTime = Get-Date
        }
    }
    
    # Import PowerCLI with better error handling
    try {
        Update-Progress -VMName $vmEntry.VMName -Step "INITIALIZING" -Details "Loading PowerCLI module"
        
        # Try different ways to import PowerCLI
        if (Get-Module -ListAvailable -Name VMware.PowerCLI) {
            Import-Module VMware.PowerCLI -Force -ErrorAction Stop
        } elseif (Get-Module -ListAvailable -Name VMware.VimAutomation.Core) {
            Import-Module VMware.VimAutomation.Core -Force -ErrorAction Stop
        } else {
            throw "PowerCLI module not found"
        }
        
        Set-PowerCLIConfiguration -InvalidCertificateAction Ignore -Confirm:$false -Scope Session -ErrorAction SilentlyContinue
        Update-Progress -VMName $vmEntry.VMName -Step "INITIALIZED" -Details "PowerCLI loaded successfully"
    } catch {
        return [PSCustomObject]@{
            VMName = $vmEntry.VMName
            Status = "Failed"
            ErrorMessage = "Failed to load PowerCLI: $($_.Exception.Message)"
            StartTime = Get-Date
            EndTime = Get-Date
        }
    }
    
    $vmReport = [PSCustomObject]@{
        VMName = $vmEntry.VMName
        OriginalPowerState = $vmEntry.PowerState
        OriginalCPUHotAddEnabled = $vmEntry.CPUHotAddEnabled
        OriginalMemoryHotAddEnabled = $vmEntry.MemoryHotAddEnabled
        OriginalCPUCount = $vmEntry.CPUCountBefore
        TargetCPUCount = $vmEntry.CPUCountAfter
        NewCPUCount = ""
        NewCoresPerSocket = ""
        NewCPUHotAddEnabled = ""
        NewMemoryHotAddEnabled = ""
        FinalPowerState = ""
        Status = ""
        ErrorMessage = ""
        ProcessingThread = [System.Threading.Thread]::CurrentThread.ManagedThreadId
        StartTime = Get-Date
        EndTime = $null
        TotalProcessingTime = ""
    }
    
    try {
        Update-Progress -VMName $vmEntry.VMName -Step "STARTING" -Details "Beginning VM processing"
        
        # Connect to vCenter servers in this job
        Update-Progress -VMName $vmEntry.VMName -Step "CONNECTING" -Details "Connecting to vCenter servers"
        $jobConnectedServers = @()
        
        foreach ($vc in $vCenterServers) {
            try {
                $connection = Connect-VIServer -Server $vc -Credential $Credential -ErrorAction Stop
                Update-Progress -VMName $vmEntry.VMName -Step "CONNECTED" -Details "Connected to $vc"
                $jobConnectedServers += $vc
                
                # Try to find VM on this server immediately
                $testVM = Get-VM -Name $vmEntry.VMName -Server $vc -ErrorAction SilentlyContinue
                if ($testVM) {
                    Update-Progress -VMName $vmEntry.VMName -Step "VM FOUND" -Details "Found on $vc"
                    break
                }
            } catch {
                Update-Progress -VMName $vmEntry.VMName -Step "CONNECTION FAILED" -Details "Failed to connect to $vc : $($_.Exception.Message)"
            }
        }
        
        if ($jobConnectedServers.Count -eq 0) {
            throw "Failed to connect to any vCenter servers in background job"
        }
        
        # Find the specific VM
        Update-Progress -VMName $vmEntry.VMName -Step "SEARCHING" -Details "Locating VM"
        $vm = $null
        foreach ($server in $jobConnectedServers) {
            $vm = Get-VM -Name $vmEntry.VMName -Server $server -ErrorAction SilentlyContinue
            if ($vm) {
                Update-Progress -VMName $vmEntry.VMName -Step "LOCATED" -Details "Found VM on server $server"
                break
            }
        }
        
        if (!$vm) {
            throw "VM '$($vmEntry.VMName)' not found on any connected vCenter server"
        }
        
        # Step 1: Shutdown VM if powered on
        if ($vm.PowerState -eq "PoweredOn") {
            Update-Progress -VMName $vmEntry.VMName -Step "SHUTDOWN INITIATED" -Details "Sending graceful shutdown"
            Shutdown-VMGuest -VM $vm -Confirm:$false
            
            # Wait for shutdown with timeout
            $timeout = (Get-Date).AddMinutes(10)
            $shutdownStartTime = Get-Date
            
            do {
                Start-Sleep -Seconds 10
                $vm = Get-VM -Name $vmEntry.VMName -ErrorAction SilentlyContinue
                if ($vm.PowerState -eq "PoweredOff") {
                    $shutdownDuration = [math]::Round(((Get-Date) - $shutdownStartTime).TotalSeconds, 1)
                    Update-Progress -VMName $vmEntry.VMName -Step "SHUTDOWN COMPLETE" -Details "Completed in $shutdownDuration seconds"
                    break
                }
            } while ((Get-Date) -lt $timeout)
            
            if ($vm.PowerState -ne "PoweredOff") {
                Update-Progress -VMName $vmEntry.VMName -Step "FORCE SHUTDOWN" -Details "Forcing power off"
                Stop-VM -VM $vm -Confirm:$false
                Start-Sleep -Seconds 10
            }
        }
        
        # Step 2: Configure VM
        Update-Progress -VMName $vmEntry.VMName -Step "CONFIGURING" -Details "Applying new settings"
        $vm = Get-VM -Name $vmEntry.VMName
        $vmView = Get-View -VIObject $vm
        
        $targetCPUCount = [int]$vmEntry.CPUCountAfter
        $vmConfigSpec = New-Object VMware.Vim.VirtualMachineConfigSpec
        $vmConfigSpec.NumCPUs = $targetCPUCount
        $vmConfigSpec.NumCoresPerSocket = 1
        $vmConfigSpec.CpuHotAddEnabled = $true
        $vmConfigSpec.MemoryHotAddEnabled = $true
        
        $vmView.ReconfigVM($vmConfigSpec)
        Update-Progress -VMName $vmEntry.VMName -Step "CONFIGURED" -Details "Settings applied successfully"
        
        # Step 3: Power on VM
        Update-Progress -VMName $vmEntry.VMName -Step "POWERING ON" -Details "Starting VM"
        Start-VM -VM $vm -Confirm:$false
        
        # Wait for power on
        $timeout = (Get-Date).AddMinutes(10)
        do {
            Start-Sleep -Seconds 10
            $vm = Get-VM -Name $vmEntry.VMName -ErrorAction SilentlyContinue
            if ($vm.PowerState -eq "PoweredOn") {
                Update-Progress -VMName $vmEntry.VMName -Step "POWERED ON" -Details "VM started successfully"
                break
            }
        } while ((Get-Date) -lt $timeout)
        
        # Verify final configuration
        $vm = Get-VM -Name $vmEntry.VMName
        $vmView = Get-View -VIObject $vm
        
        $vmReport.NewCPUCount = $vmView.Config.Hardware.NumCPU
        $vmReport.NewCoresPerSocket = $vmView.Config.Hardware.NumCoresPerSocket
        $vmReport.NewCPUHotAddEnabled = $vmView.Config.CpuHotAddEnabled
        $vmReport.NewMemoryHotAddEnabled = $vmView.Config.MemoryHotAddEnabled
        $vmReport.FinalPowerState = $vm.PowerState
        $vmReport.Status = "Success"
        $vmReport.EndTime = Get-Date
        $vmReport.TotalProcessingTime = [math]::Round(($vmReport.EndTime - $vmReport.StartTime).TotalMinutes, 2)
        
        Update-Progress -VMName $vmEntry.VMName -Step "SUCCESS" -Details "Processing completed in $($vmReport.TotalProcessingTime) minutes"
        
        # Disconnect from vCenter
        foreach ($server in $jobConnectedServers) {
            try {
                Disconnect-VIServer -Server $server -Confirm:$false -ErrorAction SilentlyContinue
            } catch {
                # Ignore disconnect errors
            }
        }
        
    } catch {
        $vmReport.Status = "Failed"
        $vmReport.ErrorMessage = $_.Exception.Message
        $vmReport.EndTime = Get-Date
        if ($vmReport.StartTime) {
            $vmReport.TotalProcessingTime = [math]::Round(($vmReport.EndTime - $vmReport.StartTime).TotalMinutes, 2)
        }
        Update-Progress -VMName $vmEntry.VMName -Step "FAILED" -Details "Error: $($_.Exception.Message)"
    }
    
    return $vmReport
}

# Extract credential components for job passing
$Username = $Credential.UserName
$Password = $Credential.GetNetworkCredential().Password

# Start parallel processing jobs with improved monitoring
Write-Host "Starting parallel processing of $($VMList.Count) VMs..." -ForegroundColor Cyan
$jobs = @()
$maxConcurrentJobs = 3  # Reduced for better stability

foreach ($vmEntry in $VMList) {
    # Wait for available slot
    while ((Get-Job -State Running).Count -ge $maxConcurrentJobs) {
        Start-Sleep -Seconds 5
        Write-Host "Waiting for available slot... ($((Get-Job -State Running).Count)/$maxConcurrentJobs jobs running)" -ForegroundColor Yellow
    }
    
    # Start job with proper parameter passing
    $job = Start-Job -ScriptBlock $vmProcessingScript -ArgumentList $vmEntry, $vCenterServers, $Username, $Password
    $jobs += $job
    Write-Host "Started job for VM: $($vmEntry.VMName) (Job ID: $($job.Id))" -ForegroundColor Gray
    Start-Sleep -Seconds 2  # Small delay between job starts
}

# Improved job monitoring and result collection
Write-Host "`nMonitoring job progress..." -ForegroundColor Cyan
$report = @()
$completedJobs = 0
$lastUpdateTime = Get-Date

while ($jobs) {
    # Process completed jobs
    $finishedJobs = $jobs | Where-Object { $_.State -ne 'Running' }
    
    foreach ($job in $finishedJobs) {
        $completedJobs++
        Write-Host "Processing completed job $($job.Id)..." -ForegroundColor Gray
        
        try {
            # Get job output
            $jobOutput = Receive-Job -Job $job -ErrorAction Stop
            
            # Look for the result object (last object should be our report)
            $result = $jobOutput | Where-Object { $_ -is [PSCustomObject] -and $_.PSObject.Properties.Name -contains "VMName" } | Select-Object -Last 1
            
            if ($result) {
                $report += $result
                Write-Host "Collected result for VM: $($result.VMName) - Status: $($result.Status)" -ForegroundColor Green
            } else {
                Write-Warning "No result object found for job $($job.Id)"
                # Show all output for debugging
                Write-Host "Job output:" -ForegroundColor Yellow
                $jobOutput | ForEach-Object { Write-Host "  $_" -ForegroundColor Gray }
            }
            
        } catch {
            Write-Warning "Failed to process job $($job.Id): $_"
        }
        
        Remove-Job -Job $job -Force
        $jobs = $jobs | Where-Object { $_.Id -ne $job.Id }
    }
    
    # Progress update every 30 seconds
    if (((Get-Date) - $lastUpdateTime).TotalSeconds -ge 30) {
        $runningCount = ($jobs | Where-Object { $_.State -eq 'Running' }).Count
        Write-Host "Progress: $completedJobs/$($VMList.Count) completed, $runningCount running" -ForegroundColor Cyan
        $lastUpdateTime = Get-Date
    }
    
    if ($jobs) {
        Start-Sleep -Seconds 5
    }
}

# Generate final report
Write-Host "`nAll jobs completed. Generating report..." -ForegroundColor Green

if ($report.Count -gt 0) {
    $report | Export-Csv -Path $ReportPath -NoTypeInformation
    
    Write-Host "`nProcess Summary:" -ForegroundColor Cyan
    Write-Host "Total VMs processed: $($report.Count)" -ForegroundColor Yellow
    Write-Host "Successful: $(($report | Where-Object {$_.Status -eq 'Success'}).Count)" -ForegroundColor Green
    Write-Host "Failed: $(($report | Where-Object {$_.Status -eq 'Failed'}).Count)" -ForegroundColor Red
    Write-Host "Report saved to: $ReportPath" -ForegroundColor Yellow
    
    # Show results
    $report | Format-Table VMName, Status, NewCPUCount, NewCoresPerSocket, FinalPowerState, TotalProcessingTime -AutoSize
} else {
    Write-Warning "No results collected from any jobs!"
}

# Disconnect from vCenter servers
foreach ($server in $connectedServers) {
    try {
        Disconnect-VIServer -Server $server -Confirm:$false
        Write-Host "Disconnected from $server" -ForegroundColor Green
    } catch {
        Write-Warning "Failed to disconnect from $server"
    }
}

Write-Host "`nScript completed!" -ForegroundColor Green
