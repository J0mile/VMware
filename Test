Okay so I'm doing vmware scripting

I've already got asking the user for credentials to get a SDDC API token and also the credentials which get stored into a variable, this variable has the hostname, and passowrd for the root account. It willl connect to all the VCs and enable the SSH of all ESXI host.. That's sorted

I'm having issues and want to get the code for
Getting the fingerprint for first time SSH and say yes to that fingerprint. It will generate a public and private key of itself and upload the key to ssh auhtorised keys to allow it to run esxcli commands. 
This bit always having troubles as it always hangs as its interactive and asking for password credentaisl
Edit

I can help you with the SSH key generation and fingerprint acceptance part of your VMware scripting. The hanging issue you're experiencing is common when dealing with interactive SSH prompts.

Here are a few approaches to handle this programmatically:

The script above provides several methods to handle the SSH key setup without hanging on interactive prompts:
Key Features:

    Automatic Fingerprint Handling: Uses ssh-keyscan to pre-populate known_hosts, avoiding the "yes/no" fingerprint prompt
    Multiple Authentication Methods:
        sshpass (most reliable if available)
        expect scripts (for Linux/WSL environments)
        Posh-SSH PowerShell module
    Key Generation: Automatically generates SSH key pairs if they don't exist
    Non-interactive: All methods bypass interactive prompts

Installation Requirements:

For the most reliable method, install sshpass:

Windows (using Chocolatey):
powershell

choco install sshpass

Or for Posh-SSH module:
powershell

Install-Module -Name Posh-SSH -Force

Usage Example:
powershell

# Your existing credential variables
$esxiHosts = @("esxi1.domain.com", "esxi2.domain.com")
$rootPassword = $credentials.Password  # From your existing credential variable

# Setup SSH keys
Set-ESXiSSHKeys -ESXiHosts $esxiHosts -Username "root" -Password $rootPassword

# Now you can run commands without passwords
Invoke-ESXiCommand -ESXiHost "esxi1.domain.com" -Command "esxcli system version get"

The script handles the common issues that cause hanging:

    Pre-accepts host fingerprints
    Uses non-interactive SSH options (-o StrictHostKeyChecking=no)
    Provides multiple fallback methods
    Includes proper error handling

Would you like me to modify any part of this approach or help integrate it with your existing VMware scripting framework?

Don't use posh-ssh. Is there a ssh.exe on windows or plink
Edit

Yes, absolutely! Modern Windows 10/11 comes with OpenSSH client (ssh.exe) built-in, and you can also use plink.exe from PuTTY. Let me update the script to focus on these native options:

Perfect! Here's what I've updated to focus on native Windows tools:
Available SSH Tools on Windows:

    Windows 10/11 Built-in SSH (ssh.exe):
        Available by default on Windows 10 (1809+) and Windows 11
        If not available, install with: Add-WindowsCapability -Online -Name OpenSSH.Client~~~~0.0.1.0
    PuTTY plink.exe:
        Download from https://www.putty.org/
        More reliable for automation as it handles passwords better
        Use -batch flag to avoid interactive prompts

Key Improvements:

For plink.exe (Recommended for automation):
powershell

# Auto-accepts host keys and uses password authentication
plink -ssh -batch -auto_store_key_in_cache -pw $Password $Username@$ESXiHost "command"

For native ssh.exe:
powershell

# Uses options to bypass interactive prompts
ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=nul -o PreferredAuthentications=password $Username@$ESXiHost

Quick Setup Check:

The script includes a Test-SSHTools function that checks what's available:
powershell

Test-SSHTools  # Shows available SSH tools

Usage:
powershell

# Your existing variables
$esxiHosts = @("esxi1.domain.com", "esxi2.domain.com") 
$rootPassword = $credentials.Password

# Use the native Windows version
Set-ESXiSSHKeys-Native -ESXiHosts $esxiHosts -Username "root" -Password $rootPassword

plink.exe is generally more reliable for automation because:

    Better handles password input without hanging
    -batch mode prevents interactive prompts
    -auto_store_key_in_cache handles host key acceptance automatically

Would you like me to create a version that focuses specifically on plink.exe, or do you need help integrating this with your existing VMware script structure?


# VMware ESXi SSH Key Setup Script
# Handles fingerprint acceptance and key generation/upload

# Function to generate SSH key pair if it doesn't exist
function New-SSHKeyPair {
    param(
        [string]$KeyPath = "$env:USERPROFILE\.ssh\id_rsa"
    )
    
    if (-not (Test-Path $KeyPath)) {
        Write-Host "Generating SSH key pair..." -ForegroundColor Green
        ssh-keygen -t rsa -b 4096 -f $KeyPath -N '""' -q
        Write-Host "SSH key pair generated at $KeyPath" -ForegroundColor Green
    } else {
        Write-Host "SSH key pair already exists at $KeyPath" -ForegroundColor Yellow
    }
}

# Function to add host to known_hosts (bypasses fingerprint prompt)
function Add-HostToKnownHosts {
    param(
        [string]$HostName,
        [string]$KnownHostsPath = "$env:USERPROFILE\.ssh\known_hosts"
    )
    
    # Create .ssh directory if it doesn't exist
    $sshDir = Split-Path $KnownHostsPath -Parent
    if (-not (Test-Path $sshDir)) {
        New-Item -ItemType Directory -Path $sshDir -Force | Out-Null
    }
    
    # Get host key and add to known_hosts
    try {
        Write-Host "Adding $HostName to known_hosts..." -ForegroundColor Green
        $hostKey = ssh-keyscan -H $HostName 2>$null
        if ($hostKey) {
            Add-Content -Path $KnownHostsPath -Value $hostKey
            Write-Host "Host key added successfully" -ForegroundColor Green
        }
    }
    catch {
        Write-Warning "Failed to get host key for $HostName : $($_.Exception.Message)"
    }
}

# Function to upload public key to ESXi host
function Install-SSHKeyToESXi {
    param(
        [string]$ESXiHost,
        [string]$Username = "root",
        [string]$Password,
        [string]$PublicKeyPath = "$env:USERPROFILE\.ssh\id_rsa.pub"
    )
    
    if (-not (Test-Path $PublicKeyPath)) {
        throw "Public key not found at $PublicKeyPath"
    }
    
    $publicKeyContent = Get-Content $PublicKeyPath -Raw
    $publicKeyContent = $publicKeyContent.Trim()
    
    Write-Host "Installing SSH key to $ESXiHost..." -ForegroundColor Green
    
    # Method 1: Using sshpass (if available) - most reliable
    if (Get-Command sshpass -ErrorAction SilentlyContinue) {
        try {
            # Create authorized_keys directory and file
            $commands = @(
                "mkdir -p /etc/ssh/keys-root",
                "echo '$publicKeyContent' >> /etc/ssh/keys-root/authorized_keys",
                "chmod 600 /etc/ssh/keys-root/authorized_keys",
                "chmod 700 /etc/ssh/keys-root"
            )
            
            foreach ($cmd in $commands) {
                sshpass -p $Password ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null $Username@$ESXiHost $cmd
            }
            Write-Host "SSH key installed successfully on $ESXiHost" -ForegroundColor Green
            return $true
        }
        catch {
            Write-Warning "Failed to install SSH key using sshpass: $($_.Exception.Message)"
        }
    }
    
    # Method 2: Using Expect script (if on Linux/WSL)
    if ($IsLinux -or $env:WSL_DISTRO_NAME) {
        try {
            $expectScript = @"
#!/usr/bin/expect -f
set timeout 30
spawn ssh -o StrictHostKeyChecking=no $Username@$ESXiHost
expect "password:"
send "$Password\r"
expect "~]# "
send "mkdir -p /etc/ssh/keys-root\r"
expect "~]# "
send "echo '$publicKeyContent' >> /etc/ssh/keys-root/authorized_keys\r"
expect "~]# "
send "chmod 600 /etc/ssh/keys-root/authorized_keys\r"
expect "~]# "
send "chmod 700 /etc/ssh/keys-root\r"
expect "~]# "
send "exit\r"
expect eof
"@
            $expectScript | Out-File -FilePath "/tmp/ssh_key_install.exp" -Encoding UTF8
            chmod +x /tmp/ssh_key_install.exp
            expect /tmp/ssh_key_install.exp
            Remove-Item "/tmp/ssh_key_install.exp" -Force
            Write-Host "SSH key installed successfully on $ESXiHost" -ForegroundColor Green
            return $true
        }
        catch {
            Write-Warning "Failed to install SSH key using expect: $($_.Exception.Message)"
        }
    }
    
    # Method 3: Using native Windows ssh.exe with password input via stdin
    if (Get-Command ssh -ErrorAction SilentlyContinue) {
        try {
            Write-Host "Using native Windows SSH client..." -ForegroundColor Yellow
            
            # Create a temporary script to handle password input
            $tempScript = @"
@echo off
echo $Password
"@
            $tempBatFile = [System.IO.Path]::GetTempFileName() + ".bat"
            $tempScript | Out-File -FilePath $tempBatFile -Encoding ASCII
            
            # Commands to execute on ESXi
            $commands = @(
                "mkdir -p /etc/ssh/keys-root",
                "echo '$publicKeyContent' >> /etc/ssh/keys-root/authorized_keys", 
                "chmod 600 /etc/ssh/keys-root/authorized_keys",
                "chmod 700 /etc/ssh/keys-root"
            )
            
            # Execute each command
            foreach ($cmd in $commands) {
                $sshCommand = "echo `"$Password`" | ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=nul -o PreferredAuthentications=password -o PubkeyAuthentication=no $Username@$ESXiHost `"$cmd`""
                $result = cmd /c $sshCommand 2>&1
                
                if ($LASTEXITCODE -ne 0) {
                    Write-Warning "Command may have failed: $cmd"
                }
            }
            
            # Clean up temp file
            if (Test-Path $tempBatFile) {
                Remove-Item $tempBatFile -Force
            }
            
            Write-Host "SSH key installation attempted using native SSH" -ForegroundColor Green
            return $true
        }
        catch {
            Write-Warning "Failed using native SSH: $($_.Exception.Message)"
        }
    }
    
    # Method 4: Using plink.exe (PuTTY)
    if (Get-Command plink -ErrorAction SilentlyContinue) {
        try {
            Write-Host "Using plink.exe..." -ForegroundColor Yellow
            
            # Commands to execute
            $commands = @(
                "mkdir -p /etc/ssh/keys-root",
                "echo '$publicKeyContent' >> /etc/ssh/keys-root/authorized_keys",
                "chmod 600 /etc/ssh/keys-root/authorized_keys", 
                "chmod 700 /etc/ssh/keys-root"
            )
            
            foreach ($cmd in $commands) {
                # Use plink with auto-accept host key and password
                $plinkArgs = @(
                    "-ssh",
                    "-batch",
                    "-pw", $Password,
                    "$Username@$ESXiHost",
                    $cmd
                )
                
                $result = & plink @plinkArgs 2>&1
                
                if ($LASTEXITCODE -ne 0) {
                    Write-Warning "Plink command may have failed: $cmd - $result"
                }
            }
            
            Write-Host "SSH key installed successfully using plink" -ForegroundColor Green
            return $true
        }
        catch {
            Write-Warning "Failed using plink: $($_.Exception.Message)"
        }
    }
    
# Alternative function using pure Windows ssh.exe with expect-like behavior
function Install-SSHKeyToESXi-WindowsNative {
    param(
        [string]$ESXiHost,
        [string]$Username = "root", 
        [string]$Password,
        [string]$PublicKeyPath = "$env:USERPROFILE\.ssh\id_rsa.pub"
    )
    
    if (-not (Test-Path $PublicKeyPath)) {
        throw "Public key not found at $PublicKeyPath"
    }
    
    $publicKeyContent = Get-Content $PublicKeyPath -Raw
    $publicKeyContent = $publicKeyContent.Trim()
    
    Write-Host "Installing SSH key to $ESXiHost using Windows SSH..." -ForegroundColor Green
    
    # Method 1: Using Windows ssh.exe with pipeline input
    try {
        # Create commands as a single string to execute
        $commandString = @"
mkdir -p /etc/ssh/keys-root
echo '$publicKeyContent' >> /etc/ssh/keys-root/authorized_keys
chmod 600 /etc/ssh/keys-root/authorized_keys
chmod 700 /etc/ssh/keys-root
exit
"@
        
        # Write commands to temp file
        $tempFile = [System.IO.Path]::GetTempFileName()
        $commandString | Out-File -FilePath $tempFile -Encoding UTF8
        
        # Use ssh with input redirection
        $sshArgs = @(
            "-o", "StrictHostKeyChecking=no",
            "-o", "UserKnownHostsFile=nul", 
            "-o", "PreferredAuthentications=password",
            "-o", "PubkeyAuthentication=no",
            "-o", "BatchMode=no",
            "$Username@$ESXiHost"
        )
        
        # Execute SSH with password (you'll need to handle this interactively or use expect)
        Write-Host "Note: You may need to enter the password interactively" -ForegroundColor Yellow
        $result = Get-Content $tempFile | ssh @sshArgs
        
        # Clean up
        Remove-Item $tempFile -Force
        
        if ($LASTEXITCODE -eq 0) {
            Write-Host "SSH key installed successfully" -ForegroundColor Green
            return $true
        }
    }
    catch {
        Write-Warning "Method 1 failed: $($_.Exception.Message)"
    }
    
    # Method 2: Using plink if available (more reliable for automation)
    if (Get-Command plink -ErrorAction SilentlyContinue) {
        try {
            Write-Host "Using plink for automated installation..." -ForegroundColor Yellow
            
            # First, store the host key (equivalent to accepting fingerprint)
            $plinkArgs = @(
                "-ssh",
                "-batch", 
                "-auto_store_key_in_cache",
                "-pw", $Password,
                "$Username@$ESXiHost",
                "echo 'Connection test'"
            )
            
            $null = & plink @plinkArgs 2>&1
            
            # Now execute the key installation commands
            $commands = @(
                "mkdir -p /etc/ssh/keys-root",
                "echo '$publicKeyContent' >> /etc/ssh/keys-root/authorized_keys",
                "chmod 600 /etc/ssh/keys-root/authorized_keys",
                "chmod 700 /etc/ssh/keys-root"
            )
            
            foreach ($cmd in $commands) {
                $plinkArgs = @(
                    "-ssh",
                    "-batch",
                    "-pw", $Password,
                    "$Username@$ESXiHost", 
                    $cmd
                )
                
                $result = & plink @plinkArgs 2>&1
                Write-Host "Executed: $cmd" -ForegroundColor Gray
                
                if ($LASTEXITCODE -ne 0) {
                    Write-Warning "Command failed: $cmd"
                    Write-Warning "Output: $result"
                }
            }
            
            Write-Host "SSH key installation completed with plink" -ForegroundColor Green
            return $true
        }
        catch {
            Write-Warning "Plink method failed: $($_.Exception.Message)"
        }
    }
    
    return $false
}

# Function to check if SSH tools are available
function Test-SSHTools {
    $tools = @()
    
    if (Get-Command ssh -ErrorAction SilentlyContinue) {
        $tools += "Windows SSH (ssh.exe)"
    }
    
    if (Get-Command plink -ErrorAction SilentlyContinue) {
        $tools += "PuTTY plink"
    }
    
    if (Get-Command sshpass -ErrorAction SilentlyContinue) {
        $tools += "sshpass"
    }
    
    Write-Host "Available SSH tools:" -ForegroundColor Green
    $tools | ForEach-Object { Write-Host "  - $_" -ForegroundColor Yellow }
    
    if ($tools.Count -eq 0) {
        Write-Warning "No SSH tools found. Please install OpenSSH or PuTTY."
        Write-Host "To install OpenSSH: Add-WindowsCapability -Online -Name OpenSSH.Client~~~~0.0.1.0" -ForegroundColor Cyan
        Write-Host "To install PuTTY: Download from https://www.putty.org/" -ForegroundColor Cyan
    }
    
    return $tools.Count -gt 0
}
function Test-SSHKeyAuth {
    param(
        [string]$ESXiHost,
        [string]$Username = "root",
        [string]$PrivateKeyPath = "$env:USERPROFILE\.ssh\id_rsa"
    )
    
    try {
        Write-Host "Testing SSH key authentication to $ESXiHost..." -ForegroundColor Green
        $result = ssh -i $PrivateKeyPath -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null $Username@$ESXiHost "echo 'SSH key authentication successful'"
        
        if ($LASTEXITCODE -eq 0) {
            Write-Host "SSH key authentication successful for $ESXiHost" -ForegroundColor Green
            return $true
        } else {
            Write-Warning "SSH key authentication failed for $ESXiHost"
            return $false
        }
    }
    catch {
        Write-Warning "SSH key authentication test failed: $($_.Exception.Message)"
        return $false
    }
}

# Enhanced version using native Windows tools
function Set-ESXiSSHKeys-Native {
    param(
        [array]$ESXiHosts,
        [string]$Username = "root",
        [string]$Password
    )
    
    # Check available tools
    if (-not (Test-SSHTools)) {
        throw "No SSH tools available"
    }
    
    # Generate SSH key pair
    New-SSHKeyPair
    
    $publicKeyPath = "$env:USERPROFILE\.ssh\id_rsa.pub"
    $privateKeyPath = "$env:USERPROFILE\.ssh\id_rsa"
    
    foreach ($esxiHost in $ESXiHosts) {
        Write-Host "`nProcessing ESXi host: $esxiHost" -ForegroundColor Cyan
        
        try {
            # Add host to known_hosts to avoid fingerprint prompt
            Add-HostToKnownHosts -HostName $esxiHost
            
            # Try the native Windows approach
            $success = Install-SSHKeyToESXi-WindowsNative -ESXiHost $esxiHost -Username $Username -Password $Password -PublicKeyPath $publicKeyPath
            
            if ($success) {
                # Test the key authentication
                Start-Sleep -Seconds 2
                Test-SSHKeyAuth -ESXiHost $esxiHost -Username $Username -PrivateKeyPath $privateKeyPath
            } else {
                Write-Error "Failed to install SSH key on $esxiHost"
            }
        }
        catch {
            Write-Error "Error processing $esxiHost : $($_.Exception.Message)"
        }
    }
}

# Example usage:
# Assuming you have your ESXi hosts and credentials
<#
$esxiHosts = @("esxi1.domain.com", "esxi2.domain.com", "esxi3.domain.com")
$rootPassword = "YourRootPassword"

Set-ESXiSSHKeys -ESXiHosts $esxiHosts -Username "root" -Password $rootPassword
#>

# Function to run esxcli commands using SSH key
function Invoke-ESXiCommand {
    param(
        [string]$ESXiHost,
        [string]$Command,
        [string]$Username = "root",
        [string]$PrivateKeyPath = "$env:USERPROFILE\.ssh\id_rsa"
    )
    
    try {
        $result = ssh -i $PrivateKeyPath -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null $Username@$ESXiHost $Command
        return $result
    }
    catch {
        Write-Error "Failed to execute command on $ESXiHost : $($_.Exception.Message)"
        return $null
    }
}
